% !TEX program = lualatex
\documentclass[11pt, a4paper]{article}

% --- UNIVERSAL PREAMBLE BLOCK ---
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}
\usepackage{fontspec}
\usepackage{booktabs} % For professional-looking tables
\usepackage{longtable} % For tables that span multiple pages
\usepackage{amsmath} % For math environments
\usepackage{xcolor} % For colors
\usepackage{listings} % For code snippets
\usepackage{hyperref} % Always load last
\usepackage{graphicx}

\usepackage[english, bidi=basic, provide=*]{babel}
\babelprovide[import, onchar=ids fonts]{english}

% Set default/Latin font to Sans Serif in the main (rm) slot
\babelfont{rm}{Noto Sans}
% --- END UNIVERSAL PREAMBLE BLOCK ---

\title{\textbf{Vector Intermediate Language (VIL) \\
\large Gas-Efficient Vector VM as a Smart-Contract in Rust / Stylus (WASM)}}
\author{Sonia Kolasinska, IndexMaker Labs}
\date{\today}

\begin{document}
\maketitle
\thispagestyle{empty} % Suppress page number on the title page
\setlength{\parskip}{0.8em}
\setlength{\parindent}{0em}

\vspace{1cm}

\pagebreak
\section{Introduction: The VM$^2$ Architecture}

The Vector Intermediate Language (VIL) Virtual Machine (VM) represents a modern approach to deploying complex mathematical and financial logic onto the Arbitrum ecosystem using Rust / Stylus.

\begin{center}
This is \emph{VM$^2$} architecture --- Virtual Machine (VIL) running as a smart contract \\
within Virtual Machine (WASM, hosted by Arbitrum node).
\end{center}

\subsection{Project Location}
The complete project can be found at: \href{https://github.com/IndexMaker/deindex/tree/main}{\texttt{github.com/IndexMaker/deindex}}

\subsection{Motivation: Gas Efficiency through On-Chain Vector Operations}

The primary innovation of VIL is the substantial gas savings realized by relocating complex vector algebra directly into the smart contract's state and execution context.

In traditional EVM smart contract systems, performing vector operations often requires:
\begin{enumerate}
    \item Loading raw data from storage (\texttt{SLOAD}).
    \item Storing raw data into storage (\texttt{SSTORE}).
    \item (De)Serializing structured data (e.g. \texttt{Vec<u128>}) between contract calls.
    \item Passing large data arrays as call data, incurring significant calldata gas costs.
    \item Executing memory-intensive loops in the EVM, which is highly gas-inefficient for array processing.
\end{enumerate}

\textbf{VIL eliminates these bottlenecks:}

\begin{itemize}
    \item \textbf{Zero Serialization Overhead:} Vector data, stored as a pure binary blob (\texttt{Vec<Amount>}; where \texttt{Amount} is \texttt{u128} wrapper type), is loaded directly into the VIL execution environment within the same smart contract. All vector operations (addition, subtraction, multiplication, etc.) happen purely within the VIL execution context, \textbf{avoiding expensive EVM-based serialization and ABI encoding/decoding between logic steps}.
    \item \textbf{Optimal Data Flow:} Data is loaded \textbf{once} from a single storage slot (\texttt{SLOAD}), processed entirely, and stored back once (\texttt{SSTORE}), maximizing efficiency within the WASM environment.
    \item \textbf{WASM Optimization:} By executing the core logic via a simple, specialized instruction set (VIL), the underlying WASM runtime can execute vector mathematics far more efficiently than general-purpose EVM bytecode.
\end{itemize}

\pagebreak
\subsection{Design Philosophy: The Mathematical Co-processor Model}

The architecture of the VIL VM is designed under the principle of hardware specialization:

\begin{center}
    \textsl{\quotedblbase \textsl{The VIL VM is to the Stylus/WASM smart contract what the x87 FPU co-processor \\ was to the x86 CPU.}\quotedblbase}
\end{center}

The VIL's stack-based architecture is prioritizing computational efficiency over general-purpose flexibility. This approach is rooted in the history of specialized math processing and draws explicit architectural inspiration from two sources:

\begin{enumerate}
    \item The \textsl{Intel x87 Floating Point Unit (FPU) co-processor}, which accelerated complex arithmetic using a dedicated register stack to minimize reliance on general-purpose memory access.
    \item The stack-based data flow popularized by \textsl{Hewlett-Packard (HP) calculators} utilizing \textsl{Reverse Polish Notation (RPN)}, which demonstrated the extreme efficiency of a stack-centric model for complex, multi-step calculation.
\end{enumerate}

The VIL VM is architected to function as a specialized \textsl{mathematical co-processor} within the Stylus/WASM environment. This design leverages a highly optimized internal stack for vector, scalar, and label manipulation, enabling gas-efficient execution of complex vector algebra (e.g., \texttt{ADD}, \texttt{MUL} and \texttt{JADD}) without incurring the memory and gas overhead associated with deep memory reads/writes inherent in EVM and general WASM array processing.

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{VIL_Stack.jpg}\label{fig:stack_arch}
    \caption{Conceptual VIL VM Stack and Data Flow.}
\end{figure}

\pagebreak
\section{Development Workflow with the \texttt{abacus!()} Proc Macro}

Writing raw instruction bytes and operands for any VM is tedious and error-prone. The \texttt{abacus!()} procedural macro simplifies VIL program creation by allowing developers to embed native VIL assembly code directly within Rust functions.

\subsection{Macro Functionality}

The \texttt{abacus!()} macro transpiles the human-readable VIL assembly language into an efficient, executable bytecode array (\texttt{Vec<u8>}). This allows for:

\begin{itemize}
    \item \textbf{Readability:} Programs are easy to audit and maintain.
    \item \textbf{Type Safety:} The underlying Rust environment ensures correct operand types (e.g., \texttt{u128} storage IDs, registry names) are used.
    \item \textbf{Concise Syntax:} Eliminates the need for manual byte array construction.
\end{itemize}

\subsection{Usage Example}

The following snippet demonstrates how a complex sequence of data retrieval and vector operations is expressed concisely using the macro:

\begin{verbatim}
use abacus_macros::abacus;

pub fn execute_buy_order(...) -> Vec<u8> {
    abacus! {
        LDV         asset_weights_id                // Load from Blockchain (SLOAD)
        STR         _Weights                        // Store into registry
        // ...

        LDR         _CappedIndexQuantity            // Load from registry
        LDM         _Weights                        // Move from registry
        MUL         1                               // Multiply
        // ...

        LDM         _AssetQuantities                // Move from registry
        STV         executed_asset_quantities_id    // Store into Blockchain (SSTORE)
    }
}
\end{verbatim}

\pagebreak
\section{VIL Instruction Set Reference}

The VIL instruction set is designed around the concept of a stack machine operating on two primary data types: $Scalar$ (\texttt{Amount}) and $Vector$ (\texttt{Vec<Amount>}), and additionally $Labels$ (\texttt{Vec<u128>}), which enable $Join$ operations (e.g. \texttt{JADD}, \texttt{JUPD}, \texttt{JFLT}). The instructions manipulate the stack and the internal registry (\texttt{R0}...\texttt{Rn}).

\subsection*{Instruction Set Conventions and Notation}

The following conventions are used throughout the instruction set documentation to provide a clear, standardized representation of VIL stack operations, register access, and state assignments, reflecting the architecture's stack-based design inspired by the x87 FPU.

\begin{itemize}
    \item[\texttt{[TOS]}] Denotes the operand currently residing on the \textbf{Top of the Stack}.
    \item[\texttt{[TOS - N]}] Denotes the operand located $N$ positions below the top of the stack. \\
                              For instance, \texttt{[TOS - 1]} refers to the operand immediately below the top element.
    \item[\texttt{\_Name}] In usage examples, names beginning with an underscore (e.g., \texttt{\_AssetWeights}) refer to dedicated VIL registers. These names are automatically associated with register indices by the \texttt{abacus!()} procedural macro.
    \item[$A \leftarrow B$] A left arrow in mathematical notation indicates an assignment operation. \\
    The value or result on the right-hand side is assigned to the destination on the left-hand side.
    For example, $[TOS] \leftarrow [TOS] + [TOS - 1]$ means the sum of the top two stack operands is stored back onto the top of the stack.
\end{itemize}

\pagebreak
\subsection*{Instruction Set Quick Reference}
\addcontentsline{toc}{subsection}{---  Set Quick Reference}
Quick listing of instructions.


\begin{longtable}{p{0.15\linewidth} p{0.75\linewidth}}
\caption{VIL ---  Set Summary}\label{tab:vil_summary}\\
\toprule
\textbf{Mnemonic} & \textbf{Brief Description} \\
\midrule
\endfirsthead
\multicolumn{2}{c}%
{\tablename\ \thetable\ -- Continued from previous page} \\
\toprule
\textbf{Mnemonic} & \textbf{Brief Description} \\
\midrule
\endhead
\bottomrule
\endfoot
\bottomrule
\endlastfoot
\hyperref[inst:ldl]{\texttt{LDL}} & Load Labels from Storage \\
\hyperref[inst:ldv]{\texttt{LDV}} & Load Vector from Storage \\
\hyperref[inst:ldd]{\texttt{LDD}} & Load Duplicate from Stack \\
\hyperref[inst:ldr]{\texttt{LDR}} & Load Duplicate from Registry \\
\hyperref[inst:ldm]{\texttt{LDM}} & Load Moving from Register \\
\hyperref[inst:stl]{\texttt{STL}} & Store Labels into Storage \\
\hyperref[inst:stv]{\texttt{STV}} & Store Vector into Storage \\
\hyperref[inst:str]{\texttt{STR}} & Store Moving into Registry \\
\hyperref[inst:pkv]{\texttt{PKV}} & Pack Scalar values into Vector \\
\hyperref[inst:pkl]{\texttt{PKL}} & Pack Label values into Labels object \\
\hyperref[inst:unpk]{\texttt{UNPK}} & Unpack values from Vector / Labels \\
\hyperref[inst:vpush]{\texttt{VPUSH}} & Push Scalar onto Vector \\
\hyperref[inst:vpop]{\texttt{VPOP}} & Pop Scalar from Vector \\
\hyperref[inst:t]{\texttt{T}} & Transpose Vectors on Stack \\
\hyperref[inst:lunion]{\texttt{LUNION}} & Union of Lables \\
\hyperref[inst:lpush]{\texttt{LPUSH}} & Push Label onto Labels \\
\hyperref[inst:lpop]{\texttt{LPOP}} & Pop Label from Labels \\
\hyperref[inst:jupd]{\texttt{JUPD}} & Update (Replace) by Joining on Labels \\
\hyperref[inst:jadd]{\texttt{JADD}} & Add by Joining on Labels \\
\hyperref[inst:jflt]{\texttt{JFLT}} & Filter by Joining on Labels \\
\hyperref[inst:add]{\texttt{ADD}} & Addition \\
\hyperref[inst:sub]{\texttt{SUB}} & Substraction \\
\hyperref[inst:ssb]{\texttt{SSB}} & Saturating Subraction \\
\hyperref[inst:mul]{\texttt{MUL}} & Multiplication \\
\hyperref[inst:div]{\texttt{DIV}} & Division \\
\hyperref[inst:sqrt]{\texttt{SQRT}} & Square Root \\
\hyperref[inst:min]{\texttt{MIN}} & Minimum \\
\hyperref[inst:max]{\texttt{MAX}} & Maximum \\
\hyperref[inst:vsum]{\texttt{VSUM}} & Sum of Vector components \\
\hyperref[inst:vmin]{\texttt{VMIN}} & Minimum component of a Vector \\
\hyperref[inst:vmax]{\texttt{VMAX}} & Maximum component of a Vector \\
\hyperref[inst:imms]{\texttt{IMMS}} & Push Scalar on Stack \\
\hyperref[inst:imml]{\texttt{IMML}} & Push Label on Stack \\
\hyperref[inst:zeros]{\texttt{ZEROS}} & Zero Vector \\
\hyperref[inst:ones]{\texttt{ONES}} & Unit Vector \\
\hyperref[inst:popn]{\texttt{POPN}} & Pop N levels from Stack \\
\hyperref[inst:swap]{\texttt{SWAP}} & Swap levels on Stack \\
\hyperref[inst:b]{\texttt{B}} & Branch into stored procedure \\
\hyperref[inst:fold]{\texttt{FOLD}} & Apply stored procedure to all components \\
\end{longtable}


\vspace{0.5cm} % Add some space after the table

\pagebreak
\subsection{Data Loading \& Stack Access (Opcode 10..15)}

\subsubsection{\texttt{LDL} --- Load Labels from Storage\label{inst:ldl}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Load (\texttt{Labels}) object by $ID$ from \textsl{Vector I/O (VIO)}.

This is relatively gas-expensive operation as it will load binary blob from \textsl{Blockchain} using underlying \texttt{(SLOAD)} operatation.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{labels\_id: u128} -- An $ID$ of the $Labels$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Labels} -- $Labels$ object loaded from vector storage.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}
    LDL     asset_names_id
\end{verbatim}

Load $Labels$ with `asset\_names\_id' ID from vector storage.

\pagebreak
\subsubsection{\texttt{LDV} --- Load Vector from Storage\label{inst:ldv}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Load (\texttt{Vector}) object by $ID$ from \textsl{Vector I/O (VIO)}.

This is relatively gas-expensive operation as it will load binary blob from \textsl{Blockchain} using underlying \texttt{(SLOAD)} operatation.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{labels\_id: u128} -- An $ID$ of the $Vector$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector} -- $Vector$ object loaded from vector storage.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     asset_weights_id

\end{verbatim}

Load $Vector$ with `asset\_weights\_id' ID from vector storage.

\pagebreak
\subsubsection{\texttt{LDD} --- Load Duplicate from Stack\label{inst:ldd}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Load duplicate (copy) of stack operand at \texttt{T - pos}.

This is mildly gas-expensive operation, much less gas-expensive than load from
vector storage, but still it requires cloning of a vector.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{TOS} from where we want to duplicate an operand.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS - pos]} -- Source operand to be cloned.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Duplicate of the operand at \texttt{TOS - pos}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDD     3

\end{verbatim}

Create a duplicate of the operand three levels deep on the stack.

\pagebreak
\subsubsection{\texttt{LDR} --- Load Duplicate from Registry \label{inst:ldr}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Load duplicate (copy) from registry \texttt{reg}.

This is mildly gas-expensive operation, much less gas-expensive than load from
vector storage, but still it requires cloning of a vector.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{reg: u8} -- Register number \texttt{0..num\_registry}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Duplicate of the registry \texttt{reg}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDR     _AssetWeights

\end{verbatim}

Create a duplicate of the register allocated for \texttt{\_AssetWeights}.

The \texttt{\_AssetWeights} is a convenience label we associate with some register when we use \texttt{abacus!()} macro.

\pagebreak
\subsubsection{\texttt{LDM} --- Load Moving from Register\label{inst:ldm}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Load value moving it out of registry \texttt{reg}.

This is highly gas-effective operation, as operand is moved from register onto stack without copying.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{reg: u8} -- Register number \texttt{0..num\_registry}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Value moved out of the registry \texttt{reg}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDM     _MarketAssetPrices

\end{verbatim}

Move \texttt{\_MarketAssetPrices} value out of register, and place it on stack.

The \texttt{\_MarketAssetPrices} is a convenience label we associate with some register when we use \texttt{abacus!()} macro.

\pagebreak
\subsection{Data Storage \& Register Access (Opcode 20..23)}

\subsubsection{\texttt{STL} --- Store Labels into Storage\label{inst:stl}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Store (\texttt{Labels}) object by $ID$ into \textsl{Vector I/O (VIO)}.

This is relatively gas-expensive operation as it will store binary blob into \textsl{Blockchain} using underlying \texttt{(SSTORE)} operatation.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{labels\_id: u128} -- An $ID$ of the $Labels$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Operand on stack to be moved into vector storage \texttt{labels\_id}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    STL     market_asset_names_id

\end{verbatim}

Pop value from stack \texttt{[TOS]} and store it into vector storage with  `market\_asset\_names' ID.


\pagebreak
\subsubsection{\texttt{STV} --- Store Vector into Storage\label{inst:stv}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Store (\texttt{Vector}) object by $ID$ into \textsl{Vector I/O (VIO)}.

This is relatively gas-expensive operation as it will store binary blob into \textsl{Blockchain} using underlying \texttt{(SSTORE)} operatation.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{vector\_id: u128} -- An $ID$ of the $Vector$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Operand on stack to be moved into vector storage \texttt{vector\_id}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    STV     market_asset_prices

\end{verbatim}

Pop value from stack \texttt{[TOS]} and store it into vector storage with  `market\_asset\_prices' ID.

\pagebreak
\subsubsection{\texttt{STR} --- Store Moving into Registry\label{inst:str}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Move value from stack and store it into registry \texttt{reg}.

This is highly gas-effective operation, as operand is moved from stack into register without copying.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{reg: u8} -- Register number \texttt{0..num\_registry}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Operand on stack to be moved into registry \texttt{reg}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    STR     _AssetWeights

\end{verbatim}

Pop value from stack \texttt{[TOS]} and store it in register allocated for  \texttt{\_AssetWeights}.

\pagebreak
\subsection{Data Structure Manipulation (Opcode 30..35)}

\subsubsection{\texttt{PKV} --- Pack Scalar values into Vector\label{inst:pkv}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Pack \texttt{count} $Scalar$ type values from stack into a new $Vector$.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of stack levels starting from \texttt{[TOS]} that we want to pack into $Vector$.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Scalar} -- Operand on stack to be packed as last element of resulting $Vector$.
\item [...]
\item \texttt{[TOS - count]: Scalar} -- Operand on stack to be packed as first element of resulting $Vector$.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- $Vector$ contructed from stack operands \texttt{[TOS - count], ..., [TOS]}
\item \textsl{(stack shifted by `count' levels)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDR     _Capacity
    LDR     _Price
    LDR     _Slope
    PKV     3

\end{verbatim}

Load three values from registry: \texttt{\_Capacity}, \texttt{\_Price}, \texttt{\_Slope}, and then pack them into single $Vector$: \texttt{[\_Capacity, \_Price, \_Slope]}.

\pagebreak
\subsubsection{\texttt{PKL} --- Pack Label values into Labels object\label{inst:pkl}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Pack \texttt{count} $Label$ type values from stack into a new $Labels$.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of stack levels starting from \texttt{[TOS]} that we want to pack into $Labels$.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Label} -- Operand on stack to be packed as last element of resulting $Labels$.
\item [...]
\item \texttt{[TOS - count]: Label} -- Operand on stack to be packed as first element of resulting $Labels$.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- $Labels$ contructed from stack operands \texttt{[TOS - count], ..., [TOS]}
\item \textsl{(stack shifted by `count' levels)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMML    btc_label
    IMML    eth_label
    IMML    xrp_label
    PKL     3

\end{verbatim}

Load three $Label$ constants: \texttt{btc\_label}, \texttt{eth\_label}, \texttt{xrp\_label}, and then pack them into single $Labels$: \texttt{[btc\_label, eth\_label, xrp\_label]}.


\pagebreak
\subsubsection{\texttt{UNPK} --- Unpack values from Vector / Labels\label{inst:unpk}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Unpack a $Vector$ / $Labels$ object onto the stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \textsl{(no operands)}
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector|Labels} -- An object to be unpacked onto stack $Vector$ / $Labels$: \texttt{[[0], ..., [count - 1]]}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Scalar|Label} -- Component unpacked as last from $Vector$ / $Labels$.
\item [...]
\item \texttt{[TOS - count]: Scalar|Label} -- Component unpacked as first from $Vector$ / $Labels$.
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     index_quote_id
    UNPK

\end{verbatim}

Load a $Vector$ from vector storage with `index\_quote\_id' ID, and unpack its components onto stack. Given that `index\_quote\_id' points to a vector, the component of which are: \texttt{[capacity, price, slope]}, the resulting stack will have structure: \texttt{[(previous stack state)..., capacity, price, slope]}, where the value of `slope' will be on \texttt{[TOS]}.

\pagebreak
\subsubsection{\texttt{VPUSH} --- Push Scalar onto Vector\label{inst:vpush}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Pushes a scalar onto the $Vector$. 

This is gas-efficient in-place operation, as it updates a $Vector$ on \texttt{[TOS]}, appending new component at the end.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{scalar: Scalar} -- Constant $Scalar$ value to be pushed onto $Vector$ at \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len]} -- A $Vector$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len + 1]} -- Resulting $Vector$ of length $len + 1$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     weights_id
    VPUSH   10.0

\end{verbatim}

Load from storage a vector with `weights\_id' ID, and push scalar constant $10.0$ to the end of it.

\textbf{Note} This does not modify the vector in-storage, and only its on-stack copy is modified. To store this modified vector back into storage separate \texttt{STV} instruction is required.


\pagebreak
\subsubsection{\texttt{VPOP} --- Pop Scalar from Vector\label{inst:vpop}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Pop a scalar from the $Vector$.

This is gas-efficient in-place operation, as it updates a $Vector$ on \texttt{[TOS]}, removing its last component.

\noindent \textbf{Operands}

\begin{itemize}
\item \textsl{(no operands)}
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len]} -- A $Vector$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len - 1]} -- Resulting $Vector$ of length $len - 1$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     weights_id
    VPOP

\end{verbatim}

Load from storage a vector with `weights\_id' ID, and pop last element from the end of it.

\textbf{Note} This does not modify the vector in-storage, and only its on-stack copy is modified. To store this modified vector back into storage separate \texttt{STV} instruction is required.

\pagebreak
\subsubsection{\texttt{T} --- Transpose Vectors on Stack\label{inst:t}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Perform matrix transposition of $M$ vectors on the stack, each of length $N$.

$$
\begin{pmatrix}
    a_{1,1} & a{1,2} & \cdots & a_{1,N} \\
    a_{2,1} & a{2,2} & \cdots & a_{2,N} \\
    \vdots  & \vdots  & \ddots & \vdots \\
    a_{M,1} & a_{M,2} & \cdots & a_{M,N} \\
\end{pmatrix}^{T}
\Rightarrow
\begin{pmatrix}
    a_{1,1} & a{2,1} & \cdots & a_{M,1} \\
    a_{1,2} & a{2,2} & \cdots & a_{M,2} \\
    \vdots  & \vdots  & \ddots & \vdots \\
    a_{1,N} & a_{2,N} & \cdots & a_{M,N} \\
\end{pmatrix}
$$

This is gas-efficient in-place operation, which updates $M$ vectors on the stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of vectors on the stack to transpose together.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector} -- A $Vector$ of length `len'.
\item [...]
\item \texttt{[TOS - count]: Vector} -- A $Vector$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector} -- A $Vector$ of length `count'.
\item [...]
\item \texttt{[TOS - len]: Vector} -- A $Vector$ of length `count'.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     index_a_quote_id
    LDV     index_b_quote_id
    LDV     index_c_quote_id
    T       3

\end{verbatim}

Load from vector storage three vectors with IDs: \\

~~~~ \texttt{index\_a\_quote\_id, index\_b\_quote\_id, index\_c\_quote\_id}, \\

and then transpose them into vectors:

\begin{verbatim}
    [index_a_capacity, index_b_capacity, index_c_capacity],
    [index_a_price, index_b_price, index_c_price],
    [index_a_slope, index_b_slope, index_c_slope],
\end{verbatim}

or simply: \\

~~~~ \texttt{capacities}, \texttt{prices}, \texttt{slopes}.


\pagebreak
\subsection{Labels Manipulation (Opcode 40..46)}

\subsubsection{\texttt{LUNION} --- Union of Lables\label{inst:lunion}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Union of two operands of $Labels$ type.

This is gas-efficient in-place operation of complexity $O(N + M)$.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8}: Position on stack of the other $Labels$ object relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Labels} -- The $Labels$ object to be extended.
\item \texttt{[TOS - pos]: Labels} -- The $Labels$ objects containing additional labels.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Resulting $Labels$ object containig original and additional labels.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDL         asset_weights
    LDL         market_asset_weights
    LUNION      1

\end{verbatim}

Load two objects of type $Labels$ from storage with IDs: \texttt{asset\_weights} and \texttt{market\_asset\_weights}, and then modify last labels on \texttt{[TOS]} \textsl{\texttt{market\_asset\_weights}} by adding labels from \texttt{[TOS - 1]} stack level \textsl{\texttt{asset\_weights}}. Resulting labels will contain all original labels from \texttt{market\_asset\_weights} and new labels from \texttt{asset\_weights}.

\pagebreak
\subsubsection{\texttt{LPUSH} --- Push Label onto Labels\label{inst:lpush}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Pushes a $Label$ onto the $Labels$. 

This is gas-efficient in-place operation, as it updates a $Labels$ on \texttt{[TOS]}, appending new component at the end.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{label: Label} -- Constant $Label$ to be pushed onto $Labels$ at \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Labels[0..len]} -- A $Labels$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Labels[0..len + 1]} -- Resulting $Labels$ of length $len + 1$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDL     asset_names_id
    LPUSH   eth_label

\end{verbatim}

Load from storage the labels with `asset\_names\_id' ID, and push label constant `eth\_label' to the end of it.

\textbf{Note} This does not modify the labels in-storage, and only its on-stack copy is modified. To store this modified labels back into storage separate \texttt{STL} instruction is required.

\pagebreak
\subsubsection{\texttt{LPOP} --- Pop Label from Labels\label{inst:lpop}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Pop a label from the $Labels$.

This is gas-efficient in-place operation, as it updates a $Labels$ on \texttt{[TOS]}, removing its last component.

\noindent \textbf{Operands}

\begin{itemize}
\item \textsl{(no operands)}
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Labels[0..len]} -- A $Labels$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Labels[0..len - 1]} -- Resulting $Labels$ of length $len - 1$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDL     asset_names_id
    VPOP

\end{verbatim}

Load from storage the labels with `asset\_names\_id' ID, and pop a label from the end of it.

\textbf{Note} This does not modify the labels in-storage, and only its on-stack copy is modified. To store this modified labels back into storage separate \texttt{STL} instruction is required.


\pagebreak
\subsubsection{\texttt{JUPD} --- Update (Replace) by Joining on Labels\label{inst:jupd}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Update $Vector$ on top of the stack (\texttt{[TOS]}) by replacing its selected components
with values from another vector on stack at \texttt{[TOS - pos\_B]}
joining on $Labels$.

This is an efficient operation of complexity $O(N)$ \textsl{(for contiguous overlaps)}
or $O(N \times \log M)$ \textsl{(for overlaps with gaps)}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos\_B: u8} -- Stack position of $Vector B$ relative to \texttt{[TOS]}.
\item \texttt{lab\_A: u8} -- Stack position of $Labels A$ relative to \texttt{[TOS]}.
\item \texttt{lab\_B: u8} -- Stack position of $Labels B$ relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- Vector A
\item \texttt{[TOS - pos\_B: Vector]} -- Vector B
\item \texttt{[TOS - lab\_A: Labels]} -- Labels A
\item \texttt{[TOS - lab\_B: Labels]} -- Labels B
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]}: -- $Vector A$ updated by replacing values from $Vector B$ mapping them through projection of $Labels B$ onto $Labels A$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    JUPD    2   4   5

\end{verbatim}

Update vector on stack at \texttt{[TOS]} by replacing its selected components with components of a vector at \texttt{[TOS - 2]},
using labels at \texttt{[TOS - 4]} for vector at \texttt{[TOS]}, and
using labels at \texttt{[TOS - 5]} for vector at \texttt{[TOS - 2]},
where labels overlap.

\pagebreak
\subsubsection{\texttt{JADD} --- Add by Joining on Labels\label{inst:jadd}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Add two $Vectors$ joining on $Labels$. Expands vector at \texttt{[TOS - pos\_B]} using labels at \texttt{[TOS - lab\_B]} 
to match labels of vector at \texttt{TOS} located on stack at \texttt{[TOS - lab\_A]}.

This is an efficient operation of complexity $O(N)$ \textsl{(for contiguous overlaps)}
or $O(N \times \log M)$ \textsl{(for overlaps with gaps)}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos\_B: u8} -- Stack position of $Vector B$ relative to \texttt{[TOS]}.
\item \texttt{lab\_A: u8} -- Stack position of $Labels A$ relative to \texttt{[TOS]}.
\item \texttt{lab\_B: u8} -- Stack position of $Labels B$ relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector A$
\item \texttt{[TOS - pos\_B: Vector]} -- $Vector B$
\item \texttt{[TOS - lab\_A: Labels]} -- $Labels A$
\item \texttt{[TOS - lab\_B: Labels]} -- $Labels B$
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]}: -- $Vector A$ updated by adding values from $Vector B$ mapping them through projection of $Labels B$ onto $Labels A$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    JADD    2   4   5

\end{verbatim}

Add to vector on stack at \texttt{[TOS]} selected components of a vector at \texttt{[TOS - 2]},
using labels at \texttt{[TOS - 4]} for vector at \texttt{[TOS]}, and
using labels at \texttt{[TOS - 5]} for vector at \texttt{[TOS - 2]},
where labels overlap.

\pagebreak
\subsubsection{\texttt{JFLT} --- Filter by Joining on Labels\label{inst:jflt}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Filter vector on stack at \texttt{[TOS]} retaining only components corresponding to labels at \texttt{[TOS - lab\_B]}
using labels at \texttt{[TOS - lab\_A]} for vector at \texttt{[TOS]}, and
where labels overlap.

This is an efficient operation of complexity $O(N)$ \textsl{(for contiguous overlaps)}
or $O(N \times \log M)$ \textsl{(for overlaps with gaps)}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{lab\_A: u8} -- Stack position of $Labels A$ relative to \texttt{[TOS]}.
\item \texttt{lab\_B: u8} -- Stack position of $Labels B$ relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector A$
\item \texttt{[TOS - lab\_A: Labels]} -- $Labels A$
\item \texttt{[TOS - lab\_B: Labels]} -- $Labels B$
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]}: -- $Vector A$ filtered by retaining components through projection of $Labels B$ onto $Labels A$.
\end{itemize}   

\noindent \textbf{Usage Example}

\begin{verbatim}

    JFLT    4   5

\end{verbatim}

Filter vector on stack at \texttt{[TOS]} retaining only components corresponding to labels at \texttt{[TOS - 5]}
using labels at \texttt{[TOS - 4]} for vector at \texttt{[TOS]}, and
where labels overlap.

\pagebreak
\subsection{Arithmetic \& Core Math (Opcode 50..55)}

\noindent \textbf{Description}

\subsubsection{\texttt{ADD} --- Addition\label{inst:add}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

Add operand at \texttt{[TOS]} to operand at \texttt{[TOS - pos]}.

$$
    [TOS] \leftarrow [TOS] + [TOS - pos]
$$

\begin{itemize}
    \item Works with vectors and scalars.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with addition.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of addition.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    5.0
    ADD     1

\end{verbatim}

Add $3.0$ to $5.0$, and replace $5.0$ with result of the addition ($8.0$).

\pagebreak
\subsubsection{\texttt{SUB} --- Substraction\label{inst:sub}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Subtract from operand at \texttt{[TOS]} an operand at \texttt{[TOS - pos]}.

\begin{itemize}
    \item Works with vectors and scalars.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with subtraction.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of subtraction.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    5.0
    SUB     1

\end{verbatim}

Subtract $3.0$ from $5.0$, and replace $5.0$ with result of the subtraction ($2.0$).

\pagebreak
\subsubsection{\texttt{SSB} --- Saturating Subraction\label{inst:ssb}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Subtract from operand at \texttt{[TOS]} an operand at \texttt{[TOS - pos]} saturating to $0$.

$$
    [TOS] \leftarrow \max([TOS] - [TOS - pos], 0)
$$

\begin{itemize}
    \item Works with vectors and scalars.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with saturating subtraction.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of saturating subtraction.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    5.0
    IMMS    3.0
    SSB     1

\end{verbatim}

Subtract $5.0$ from $3.0$ saturating at $0.0$, and replace $3.0$ with result of the saturating subtraction ($0.0$).

\pagebreak
\subsubsection{\texttt{MUL} --- Multiplication\label{inst:mul}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Multiply operand at \texttt{[TOS]} by operand at \texttt{[TOS - pos]}.

$$
    [TOS] \leftarrow [TOS] \odot [TOS - pos]
$$

\begin{itemize}
    \item Works with vectors and scalars.
    \item Multiplication of two vectors is performed component-wise.
    \item Multiplication of vector by scalar is possible, but not scalar by vector as it is an in-place operation.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with multiplication.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of multiplication.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    5.0
    MUL     1

\end{verbatim}

Multiply $3.0$ by $5.0$, and replace $5.0$ with result of the multiplication ($15.0$).

\pagebreak
\subsubsection{\texttt{DIV} --- Division\label{inst:div}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Divide operand at \texttt{[TOS]} by operand at \texttt{[TOS - pos]}.

$$
    [TOS] \leftarrow \frac{ [TOS] }{ [TOS - pos] }
$$

\begin{itemize}
    \item Works with vectors and scalars.
    \item Division of two vectors is performed component-wise.
    \item Division of vector by scalar is possible, but not scalar by vector as it is an in-place operation.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with division.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of division.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    15.0
    DIV     1

\end{verbatim}

Divide $15.0$ by $3.0$, and replace $15.0$ with result of the multiplication ($3.0$).

\pagebreak
\subsubsection{\texttt{SQRT} --- Square Root\label{inst:sqrt}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Take square root of \texttt{[TOS]}.

$$
    [TOS] \leftarrow \sqrt{[TOS]}
$$

\begin{itemize}
    \item Works with vectors and scalars. 
    \item Square root of two vector is performed component-wise.
    \item In-place updates operand on TOS.
\end{itemize}

\noindent \textbf{Notice}

This operation is implemented using \textsl{Babylonian method} of $O(\log k)$ complexity where $k$ is number of bits.
Since it is fixed point $128$-bit number, this is constant $O(1)$.

\noindent \textbf{Operands}

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand of square root.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Result of square root.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    4.0
    SQRT

\end{verbatim}

Take square root of $4.0$, and replace $4.0$ with the result ($2.0$).

\pagebreak
\subsection{Logic \& Comparison (Opcode 60..61)}

\subsubsection{\texttt{MIN} --- Minimum\label{inst:min}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Take minimum between operand at \texttt{[TOS]} and operand at \texttt{[TOS - pos]}.

$$
    [TOS] \leftarrow \min{( [TOS], [TOS - pos] )}
$$

\begin{itemize}
    \item Works with vectors and scalars.
    \item Minimum of two vectors is performed component-wise.
    \item Minimum of vector by scalar is possible, but not scalar by vector as it is an in-place operation.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with minimum.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of minimum.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    5.0
    MIN     1

\end{verbatim}

Take minimum of $5.0$ and $3.0$, and replace $5.0$ with result of the minimum ($3.0$).

\subsubsection{\texttt{MAX} --- Maximum\label{inst:max}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Take maximum between operand at \texttt{[TOS]} and operand at \texttt{[TOS - pos]}.

$$
    [TOS] \leftarrow \max{( [TOS], [TOS - pos] )}
$$

\begin{itemize}
    \item Works with vectors and scalars.
    \item Maximum of two vectors is performed component-wise.
    \item Maximum of vector by scalar is possible, but not scalar by vector as it is an in-place operation.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with maximum.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of maximum.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    5.0
    MAX     1

\end{verbatim}

Take minimum of $5.0$ and $3.0$, and replace $5.0$ with result of the minimum ($5.0$).


\pagebreak
\subsection{Vector Aggregation (Opcode 70..72)}

\subsubsection{\texttt{VSUM} --- Sum of Vector components\label{inst:vsum}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Sum of all vector components.

$$
    [TOS] \leftarrow \sum_{i=0}^{len([TOS])} \left( [TOS][i] \right)
$$

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector$ of which components to sum.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Scalar]} -- $Scalar$ sum of input vector components.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     asset_weights_id
    VSUM

\end{verbatim}

Load from storage a $Vector$ with ID `asset\_weights\_id', and compute sum of all components,
i.e. sum of all weights, and place result on \texttt{[TOS]}.

\pagebreak
\subsubsection{\texttt{VMIN} --- Minimum component of a Vector\label{inst:vmin}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Minimum value found within vector components.

$$
    [TOS] \leftarrow \min_{i=0}^{len([TOS])} \left( [TOS][i] \right)
$$

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector$ of which components minimum to find.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Scalar]} -- $Scalar$ minium of input vector components.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     asset_weights_id
    VMIN

\end{verbatim}

Load from storage a $Vector$ with ID `asset\_weights\_id', find minimum weight, and place result on \texttt{[TOS]}.


\pagebreak
\subsubsection{\texttt{VMAX} --- Maximum component of a Vector\label{inst:vmax}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Maximum value found within vector components.

$$
    [TOS] \leftarrow \max_{i=0}^{len([TOS])} \left( [TOS][i] \right)
$$

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector$ of which components maximum to find.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Scalar]} -- $Scalar$ maximum of input vector components.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     asset_weights_id
    VMAX

\end{verbatim}

Load from storage a $Vector$ with ID `asset\_weights\_id', find maximum weight, and place result on \texttt{[TOS]}.


\pagebreak
\subsection{Immediate Values \& Vector Creation (Opcode 80..83)}

\subsubsection{\texttt{IMMS} --- Push Scalar on Stack\label{inst:imms}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Push immediate $Scalar$ value on stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{value: Scalar} -- Constant $Scalar$ value to be pushed on stack.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Scalar]} -- $Scalar$ operand pushed.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    4.0

\end{verbatim}

Push constant value $4.0$ on \texttt{[TOS]}.

\pagebreak
\subsubsection{\texttt{IMML} --- Push Label on Stack\label{inst:imml}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Push immediate $Label$ value on stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{value: Label} -- Constant $Label$ value to be pushed on stack.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Label]} -- $Label$ operand pushed.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMML    btc_label

\end{verbatim}

Push constant label value `btc\_label' from Rust code onto stack.

\pagebreak
\subsubsection{\texttt{ZEROS} --- Zero Vector\label{inst:zeros}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Create Vector of zeros matching length of the operand at \texttt{[TOS - pos]}.

\begin{itemize}
    \item Works for $Vector$ and $Labels$ type of operands.
    \item Pushes new zero $Vector$ on \texttt{[TOS]}.
    \item Does not consume the operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos}: \texttt{u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS - pos: Vector|Labels]} -- $Vector$ or $Labels$ the length of which to use.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector$ of zeros with same length as input operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDL     asset_names_id
    ZEROS   1

\end{verbatim}

Load from storage $Labels$ with ID `asset\_names\_id', and then create zero $Vector$ of same length.

\pagebreak
\subsubsection{\texttt{ONES} --- Unit Vector\label{inst:ones}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Create Vector of ones matching length of the operand at \texttt{[TOS - pos]}.

\begin{itemize}
    \item Works for $Vector$ and $Labels$ type of operands.
    \item Pushes new unit $Vector$ on \texttt{[TOS]}.
    \item Does not consume the operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos}: \texttt{u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS - pos: Vector|Labels]} -- $Vector$ or $Labels$ the length of which to use.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- Unit $Vector$ with same length as input operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDL     asset_names_id
    ONES    1

\end{verbatim}

Load from storage $Labels$ with ID `asset\_names\_id', and then create unit $Vector$ of same length.


\pagebreak
\subsection{Stack Control \& Program Flow (Opcode 90..94)}

\subsubsection{\texttt{POPN} --- Pop N levels from Stack\label{inst:popn}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Pop $count$ values from the stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of levels to pop.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- First level to pop from stack.
\item \texttt{[...]}
\item \texttt{[TOS - count]}: Last level to pop from stack.
\item \textsl{(rest of stack...)}
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(rest of stack...)}
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    1.0
    IMMS    2.0
    IMMS    3.0
    IMMS    4.0
    POPN    3

\end{verbatim}

Pop $3$ levels from stack, i.e. poped elements are \textsl{2.0, 3.0, 4.0}, leaving $1.0$ on stack at \texttt{[TOS]}.

\pagebreak
\subsubsection{\texttt{SWAP} --- Swap levels on Stack\label{inst:swap}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Swap TOS with operand at \texttt{[TOS - pos]}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- First level to swap.
\item \texttt{[...]}
\item \texttt{[TOS - pos]}: Second level to swap.
\item \textsl{(rest of stack...)}
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Operand from previously second level.
\item \texttt{[...]}
\item \texttt{[TOS - pos]}: Operand from previously first level.
\item \textsl{(rest of stack...)}
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    1.0
    IMMS    2.0
    IMMS    3.0
    IMMS    4.0
    SWAP    2

\end{verbatim}

Swap $4.0$ with $2.0$, which results in stack \texttt{[1.0, 4.0, 3.0, 2.0]}, where $2.0$ is at \texttt{[TOS]}.

\pagebreak
\subsubsection{\texttt{B} --- Branch into stored procedure\label{inst:b}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Call sub-routine stored as $Code$ at `prg\_id`, supplying `N` inputs and taking `M` outputs from stack. 

The `N` inputs are consumed from stack. `M` outputs are moved from sub-routine's \texttt{[TOS]} to caller's \texttt{[TOS]}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{prg\_id: u128} -- An $ID$ of the stored procedure $Code$ object in vector storage.
\item \texttt{N: u8} -- Number of arguments to move from our stack to stack of the stored procedure before its execution.
\item \texttt{M: u8} -- Number of returned values to move back from stack of the stored procedure after its execution.
\item \texttt{R: u8} -- Number of registers to allocate for stored procedure before its execution.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Last argument
\item \texttt{[...]}
\item \texttt{[TOS - N]} -- First argument
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Last returned value
\item \texttt{[...]}
\item \texttt{[TOS - M]} -- First returned value
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDR         _Slope
    LDR         _Price
    LDR         _Collateral
    B           solve_quadratic_id  3  1  4
    STR         _IndexQuantity

\end{verbatim}

Load from registry `\_Slope', `\_Price', and `\_Collateral', and pass them as arguments to function
loaded from storage with ID `solve\_quadratic\_id'. Function returns single value, which we store into
registry as `\_IndexQuantity'.

\pagebreak
\subsubsection{\texttt{FOLD} --- Apply stored procedure to all components\label{inst:fold}} \hyperref[tab:vil_summary]{ $\Uparrow$ Back to top }

\noindent \textbf{Description}

Fold (iterate) over vector/label operands.

The behaviour of the operation is the same as \texttt{B} except sub-routine is called repeatedly over components of Vector at \texttt{[TOS]}.

This is gas-efficient method of stored procedure invocation multiple times for batch of items.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{prg\_id: u128} -- An $ID$ of the stored procedure $Code$ object in vector storage.
\item \texttt{N: u8} -- Number of arguments to move from our stack to stack of the stored procedure before its execution.
\item \texttt{M: u8} -- Number of returned values to move back from stack of the stored procedure after its execution.
\item \texttt{R: u8} -- Number of registers to allocate for stored procedure before its execution.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector|Labels} -- Iterable object of type $Vector$ or $Labels$.
\item \texttt{[TOS - 1]} -- Last argument
\item \texttt{[...]}
\item \texttt{[TOS - N - 1]} -- First argument
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Last returned value
\item \texttt{[...]}
\item \texttt{[TOS - M]} -- First returned value
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    FOLD    prg_id  N   M   R

\end{verbatim}



\end{document}