% !TEX program = lualatex
\documentclass[11pt, a4paper]{article}

% --- UNIVERSAL PREAMBLE BLOCK ---
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}
\usepackage{fontspec}
\usepackage{booktabs} % For professional-looking tables
\usepackage{longtable} % For tables that span multiple pages
\usepackage{amsmath} % For math environments
\usepackage{xcolor} % For colors
\usepackage{listings} % For code snippets
\usepackage{hyperref} % Always load last
\usepackage{graphicx}

\usepackage[english, bidi=basic, provide=*]{babel}
\babelprovide[import, onchar=ids fonts]{english}

% Set default/Latin font to Sans Serif in the main (rm) slot
\babelfont{rm}{Noto Sans}
% --- END UNIVERSAL PREAMBLE BLOCK ---

\title{\textbf{Vector Intermediate Language (VIL) \\
\large Gas-Efficient Vector VM as a Smart-Contract in Rust / Stylus (WASM)}}
\author{Sonia Kolasinska, IndexMaker Labs}
\date{\today}

\begin{document}
\maketitle
\thispagestyle{empty} % Suppress page number on the title page
\setlength{\parskip}{0.8em}
\setlength{\parindent}{0em}

\vspace{1cm}

\pagebreak
\section{Introduction: The VM$^2$ Architecture}

The Vector ---  Language (VIL) Virtual Machine represents a modern approach to deploying complex mathematical and financial logic onto the Arbitrum ecosystem using Rust / Stylus.

This architecture is a \emph{VM$^2$}---a Virtual Machine (VIL) running as a smart contract within Virtual Machine (WASM, hosted by Arbitrum node).

\subsection{Motivation: Gas Efficiency through On-Chain Vector Operations}

The primary innovation of VIL is the substantial gas savings realized by relocating complex vector algebra directly into the smart contract's state and execution context.

In traditional EVM smart contract systems, performing vector operations often requires:
\begin{enumerate}
    \item Loading raw data from storage (\texttt{SLOAD}).
    \item Storing raw data into storage (\texttt{SSTORE}).
    \item (De)Serializing structured data (e.g. \texttt{Vec<u128>}) between contract calls.
    \item Passing large data arrays as call data, incurring significant calldata gas costs.
    \item Executing memory-intensive loops in the EVM, which is highly gas-inefficient for array processing.
\end{enumerate}

\textbf{VIL eliminates these bottlenecks:}

\begin{itemize}
    \item \textbf{Zero Serialization Overhead:} Vector data, stored as a pure binary blob (\texttt{Vec<Amount>}; where \texttt{Amount} is \texttt{u128} wrapper type), is loaded directly into the VIL execution environment within the same smart contract. All vector operations (addition, subtraction, multiplication, etc.) happen purely within the VIL execution context, \textbf{avoiding expensive EVM-based serialization and ABI encoding/decoding between logic steps}.
    \item \textbf{Optimal Data Flow:} Data is loaded \textbf{once} from a single storage slot (\texttt{SLOAD}), processed entirely, and stored back once (\texttt{SSTORE}), maximizing efficiency within the WASM environment.
    \item \textbf{WASM Optimization:} By executing the core logic via a simple, specialized instruction set (VIL), the underlying WASM runtime can execute vector mathematics far more efficiently than general-purpose EVM bytecode.
\end{itemize}

\pagebreak
\section{Development Workflow with the \texttt{devil!()} Proc Macro}

Writing raw instruction bytes and operands for any VM is tedious and error-prone. The \texttt{devil!()} procedural macro simplifies VIL program creation by allowing developers to embed native VIL assembly code directly within Rust functions.

\subsection{Macro Functionality}

The \texttt{devil!()} macro transpiles the human-readable VIL assembly language into an efficient, executable bytecode array (\texttt{Vec<u8>}). This allows for:

\begin{itemize}
    \item \textbf{Readability:} Programs are easy to audit and maintain.
    \item \textbf{Type Safety:} The underlying Rust environment ensures correct operand types (e.g., \texttt{u128} storage IDs, registry names) are used.
    \item \textbf{Concise Syntax:} Eliminates the need for manual byte array construction.
\end{itemize}

\subsection{Usage Example}

The following snippet demonstrates how a complex sequence of data retrieval and vector operations is expressed concisely using the macro:

\begin{verbatim}
use devil_macros::devil;

pub fn execute_buy_order(...) -> Vec<u8> {
    devil! {
        LDV         asset_weights_id                // Load from Blockchain (SLOAD)
        STR         _Weights                        // Store into registry
        // ...

        LDR         _CappedIndexQuantity            // Load from registry
        LDM         _Weights                        // Move from registry
        MUL         1                               // Multiply
        // ...

        LDM         _AssetQuantities                // Move from registry
        STV         executed_asset_quantities_id    // Store into Blockchain (SSTORE)
    }
}
\end{verbatim}

\pagebreak
\section{VIL Instruction Set Reference}

The VIL instruction set is designed around the concept of a stack machine operating on two primary data types: \textbf{Scalar} (\texttt{Amount}) and \textbf{Vector} (\texttt{Vec<Amount>}), and additionally \textbf{Labels} (\texttt{Vec<u128>}), which enable \textsl{Join} operations (e.g. \texttt{JADD}, \texttt{JUPD}, \texttt{JFLT}). The instructions manipulate the stack and the internal registry (\texttt{R0}...\texttt{Rn}).

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{VIL_Stack.jpg}\label{fig:stack_arch}
    \caption{Conceptual VIL VM Stack and Data Flow.}
\end{figure}

\subsection*{Instruction Set Quick Reference}
\addcontentsline{toc}{subsection}{---  Set Quick Reference}
Quick listing of instructions.


\begin{longtable}{p{0.15\linewidth} p{0.75\linewidth}}
\caption{VIL ---  Set Summary}\label{tab:vil_summary}\\
\toprule
\textbf{Mnemonic} & \textbf{Brief Description} \\
\midrule
\endfirsthead
\multicolumn{2}{c}%
{\tablename\ \thetable\ -- Continued from previous page} \\
\toprule
\textbf{Mnemonic} & \textbf{Brief Description} \\
\midrule
\endhead
\bottomrule
\endfoot
\bottomrule
\endlastfoot
\hyperlink{inst:ldl}{\texttt{LDL}} & Load Labels object from VIO by ID. Pushes on TOS.. \\
\hyperlink{inst:ldv}{\texttt{LDV}} & Load Vector object from VIO by ID. Pushes on TOS.. \\
\hyperlink{inst:ldd}{\texttt{LDD}} & Load Duplicate (copy) of stack operand at $[T-pos]$. Pushes on TOS.. \\
\hyperlink{inst:ldr}{\texttt{LDR}} & Load value from Registry (R0-Rn). Pushes on TOS.. \\
\hyperlink{inst:ldm}{\texttt{LDM}} & Load value moving it out of Registry (R0-Rn). Value is removed from registry. Pushes on TOS.. \\
\hyperlink{inst:stl}{\texttt{STL}} & Store Labels object into VIO. Consumes TOS.. \\
\hyperlink{inst:stv}{\texttt{STV}} & Store Vector object into VIO. Consumes TOS.. \\
\hyperlink{inst:str}{\texttt{STR}} & Store into Registry (R0-Rn). Consumes TOS.. \\
\hyperlink{inst:pkv}{\texttt{PKV}} & Pack `count` values from stack into a new Vector. Consumes `count` operands from TOS, and replaces them with Vector.. \\
\hyperlink{inst:pkl}{\texttt{PKL}} & Pack `count` values from stack into a new Labels object. Consumes `count` operands from TOS, and replaces them with Labels.. \\
\hyperlink{inst:unpk}{\texttt{UNPK}} & Unpack a Vector/Labels object onto the stack. Consumes TOS, and replaces with its components.. \\
\hyperlink{inst:vpush}{\texttt{VPUSH}} & Push a scalar onto the Vector (TOS). In-place updates Vector on TOS, appending new component at the end.. \\
\hyperlink{inst:vpop}{\texttt{VPOP}} & Pop a scalar from the Vector (TOS). In-place updates Vector on TOS, removing last component.. \\
\hyperlink{inst:t}{\texttt{T}} & Transpose `count` vectors on stack $[V1, V2]$ -> $[T1, T2]$. In-place updates `count` operands from TOS by performing transform.. \\
\hyperlink{inst:lunion}{\texttt{LUNION}} & Union of two Labels operands (TOS and T-pos). Pushes on TOS.. \\
\hyperlink{inst:lpush}{\texttt{LPUSH}} & Push a label value onto the Labels object (TOS). In-place updates Labels on TOS, appending new component at the end.. \\
\hyperlink{inst:lpop}{\texttt{LPOP}} & Pop a label value from the Labels object (TOS). In-place updates Labels on TOS, removing last component.. \\
\hyperlink{inst:jupd}{\texttt{JUPD}} & Update using Labels. Expands vector at $[TOS - pos\_B]$ using labels at $[TOS - lab\_B]$ to match labels of TOS at $[TOS - lab\_A]$. In-place updates TOS. Consumes TOS.. \\
\hyperlink{inst:jadd}{\texttt{JADD}} & Add using Labels. Expands vector at $[TOS - pos\_B]$ using labels at $[TOS - lab\_B]$ to match labels of TOS at $[TOS - lab\_A]$. In-place updates TOS. Consumes TOS.. \\
\hyperlink{inst:jflt}{\texttt{JFLT}} & Filter using Labels. Expands vector at $[TOS-1]$ using labels at $[T-lab\_B]$ to match labels of TOS at $[T-lab\_A]$. In-place updates TOS. Does not consume other operands.. \\
\hyperlink{inst:add}{\texttt{ADD}} & Add TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:sub}{\texttt{SUB}} & Subtract TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:ssb}{\texttt{SSB}} & Saturating subtract TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:mul}{\texttt{MUL}} & Multiply TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:div}{\texttt{DIV}} & Divide TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:sqrt}{\texttt{SQRT}} & Square root of TOS (scalar or component-wise vector). Works with vectors and scalars. In-place updates operand on TOS.. \\
\hyperlink{inst:min}{\texttt{MIN}} & Min between TOS and operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:max}{\texttt{MAX}} & Max between TOS and operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:vsum}{\texttt{VSUM}} & Sum of all vector components. Pushes on TOS. Does not consume the operand.. \\
\hyperlink{inst:vmin}{\texttt{VMIN}} & Minimum value found within vector components. Pushes on TOS. Does not consume the operand.. \\
\hyperlink{inst:vmax}{\texttt{VMAX}} & Maximum value found within vector components. Pushes on TOS. Does not consume the operand.. \\
\hyperlink{inst:imms}{\texttt{IMMS}} & Push immediate Scalar value on stack. \\
\hyperlink{inst:imml}{\texttt{IMML}} & Push immediate Label value on stack. \\
\hyperlink{inst:zeros}{\texttt{ZEROS}} & Create Vector of zeros matching length of Labels at $[T-pos]$. Pushes on TOS. Does not consume the operand.. \\
\hyperlink{inst:ones}{\texttt{ONES}} & Create Vector of ones matching length of Labels at $[T-pos]$. Pushes on TOS. Does not consume the operand.. \\
\hyperlink{inst:popn}{\texttt{POPN}} & Pop 'n' values from the stack. \\
\hyperlink{inst:swap}{\texttt{SWAP}} & Swap TOS with operand at $[T-n]$. \\
\hyperlink{inst:b}{\texttt{B}} & Call sub-routine stored as Labels at `prg\_id`, supplying `N` inputs and taking `M` outputs from stack. `N` inputs are consumed from stack. `M` outputs are moved from sub-routine's TOS to caller's TOS.. \\
\hyperlink{inst:fold}{\texttt{FOLD}} & Fold (iterate) over vector/label operands. Same as `B` except sub-routine is called repeatedly over components of Vector at TOS.. \\
\end{longtable}




\vspace{0.5cm} % Add some space after the table

\pagebreak
\subsection{Data Loading \& Stack Access (Opcode 10..15)}

\subsubsection{\texttt{LDL} --- Load Labels from Storage\label{inst:ldl}}

Load (\texttt{Labels}) object by $ID$ from \textsl{Vector I/O (VIO)}.

\noindent \textbf{Notice}

This is relatively gas-expensive operation as it will load binary blob from \textsl{Blockchain} using underlying \texttt{(SLOAD)} operatation.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{labels\_id: u128} -- An $ID$ of the $Labels$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Labels} -- $Labels$ object loaded from vector storage.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}
    LDL     asset_names_id
\end{verbatim}

Load $Labels$ with `asset\_names\_id' ID from vector storage.


\pagebreak
\subsubsection{\texttt{LDV} --- Load Vector from Storage\label{inst:ldv}}

Load (\texttt{Vector}) object by $ID$ from \textsl{Vector I/O (VIO)}.

\noindent \textbf{Notice}

This is relatively gas-expensive operation as it will load binary blob from \textsl{Blockchain} using underlying \texttt{(SLOAD)} operatation.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{labels\_id: u128} -- An $ID$ of the $Vector$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector} -- $Vector$ object loaded from vector storage.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     asset_weights_id

\end{verbatim}

Load $Vector$ with `asset\_weights\_id' ID from vector storage.

\pagebreak
\subsubsection{\texttt{LDD} --- Load Duplicate from Stack\label{inst:ldd}}

Load duplicate (copy) of stack operand at \texttt{T - pos}.

\noindent \textbf{Notice}

This is mildly gas-expensive operation, much less gas-expensive than load from
vector storage, but still it requires cloning of a vector.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{TOS} from where we want to duplicate an operand.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS - pos]} -- Source operand to be cloned.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Duplicate of the operand at \texttt{TOS - pos}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDD     3

\end{verbatim}

Create a duplicate of the operand three levels deep on the stack.

\pagebreak
\subsubsection{\texttt{LDR} --- Load Duplicate from Registry \label{inst:ldr}}

Load duplicate (copy) from registry \texttt{reg}.

\noindent \textbf{Notice}

This is mildly gas-expensive operation, much less gas-expensive than load from
vector storage, but still it requires cloning of a vector.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{reg: u8} -- Register number \texttt{0..num\_registry}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Duplicate of the registry \texttt{reg}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDR     _AssetWeights

\end{verbatim}

Create a duplicate of the register allocated for \texttt{\_AssetWeights}.

The \texttt{\_AssetWeights} is a convenience label we associate with some register when we use \texttt{devil!()} macro.

\pagebreak
\subsubsection{\texttt{LDM} --- Load Moving from Register\label{inst:ldm}}

Load value moving it out of registry \texttt{reg}.

\noindent \textbf{Notice}

This is highly gas-effective operation, as operand is moved from register onto stack without copying.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{reg: u8} -- Register number \texttt{0..num\_registry}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Value moved out of the registry \texttt{reg}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDM     _MarketAssetPrices

\end{verbatim}

Move \texttt{\_MarketAssetPrices} value out of register, and place it on stack.

The \texttt{\_MarketAssetPrices} is a convenience label we associate with some register when we use \texttt{devil!()} macro.

\pagebreak
\subsection{Data Storage \& Register Access (Opcode 20..23)}

\subsubsection{\texttt{STL} --- Store Labels into Storage\label{inst:stl}}

Store (\texttt{Labels}) object by $ID$ into \textsl{Vector I/O (VIO)}.

\noindent \textbf{Notice}

This is relatively gas-expensive operation as it will store binary blob into \textsl{Blockchain} using underlying \texttt{(SSTORE)} operatation.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{labels\_id: u128} -- An $ID$ of the $Labels$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Operand on stack to be moved into vector storage \texttt{labels\_id}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    STL     market_asset_names_id

\end{verbatim}

Pop value from stack \texttt{[TOS]} and store it into vector storage with  `market\_asset\_names' ID.


\pagebreak
\subsubsection{\texttt{STV} --- Store Vector into Storage\label{inst:stv}}

Store (\texttt{Vector}) object by $ID$ into \textsl{Vector I/O (VIO)}.

\noindent \textbf{Notice}

This is relatively gas-expensive operation as it will store binary blob into \textsl{Blockchain} using underlying \texttt{(SSTORE)} operatation.


\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{vector\_id: u128} -- An $ID$ of the $Vector$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Operand on stack to be moved into vector storage \texttt{vector\_id}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    STV     market_asset_prices

\end{verbatim}

Pop value from stack \texttt{[TOS]} and store it into vector storage with  `market\_asset\_prices' ID.

\pagebreak
\subsubsection{\texttt{STR} --- Store Moving into Registry\label{inst:str}}

Move value from stack and store it into registry \texttt{reg}.

\noindent \textbf{Notice}

This is highly gas-effective operation, as operand is moved from stack into register without copying.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{reg: u8} -- Register number \texttt{0..num\_registry}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Operand on stack to be moved into registry \texttt{reg}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    STR     _AssetWeights

\end{verbatim}

Pop value from stack \texttt{[TOS]} and store it in register allocated for  \texttt{\_AssetWeights}.

\pagebreak
\subsection{Data Structure Manipulation (Opcode 30..35)}

\subsubsection{\texttt{PKV} --- Pack Scalar values into Vector\label{inst:pkv}}

Pack \texttt{count} $Scalar$ type values from stack into a new $Vector$.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of stack levels starting from \texttt{[TOS]} that we want to pack into $Vector$.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Scalar} -- Operand on stack to be packed as last element of resulting $Vector$.
\item [...]
\item \texttt{[TOS - count]: Scalar} -- Operand on stack to be packed as first element of resulting $Vector$.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- $Vector$ contructed from stack operands \texttt{[TOS - count], ..., [TOS]}
\item \textsl{(stack shifted by `count' levels)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDR     _Capacity
    LDR     _Price
    LDR     _Slope
    PKV     3

\end{verbatim}

Load three values from registry: \texttt{\_Capacity}, \texttt{\_Price}, \texttt{\_Slope}, and then pack them into single $Vector$: \texttt{[\_Capacity, \_Price, \_Slope]}.

\pagebreak
\subsubsection{\texttt{PKL} --- Pack Label values into Labels object\label{inst:pkl}}

Pack \texttt{count} $Label$ type values from stack into a new $Labels$.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of stack levels starting from \texttt{[TOS]} that we want to pack into $Labels$.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Label} -- Operand on stack to be packed as last element of resulting $Labels$.
\item [...]
\item \texttt{[TOS - count]: Label} -- Operand on stack to be packed as first element of resulting $Labels$.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- $Labels$ contructed from stack operands \texttt{[TOS - count], ..., [TOS]}
\item \textsl{(stack shifted by `count' levels)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMML    btc_label
    IMML    eth_label
    IMML    xrp_label
    PKL     3

\end{verbatim}

Load three $Label$ constants: \texttt{btc\_label}, \texttt{eth\_label}, \texttt{xrp\_label}, and then pack them into single $Labels$: \texttt{[btc\_label, eth\_label, xrp\_label]}.


\pagebreak
\subsubsection{\texttt{UNPK} --- Unpack values from Vector / Labels\label{inst:unpk}}

Unpack a $Vector$ / $Labels$ object onto the stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \textsl{(no operands)}
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector|Labels} -- An object to be unpacked onto stack $Vector$ / $Labels$: \texttt{[[0], ..., [count - 1]]}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Scalar|Label} -- Component unpacked as last from $Vector$ / $Labels$.
\item [...]
\item \texttt{[TOS - count]: Scalar|Label} -- Component unpacked as first from $Vector$ / $Labels$.
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     index_quote_id
    UNPK

\end{verbatim}

Load a $Vector$ from vector storage with `index\_quote\_id' ID, and unpack its components onto stack. Given that `index\_quote\_id' points to a vector, the component of which are: \texttt{[capacity, price, slope]}, the resulting stack will have structure: \texttt{[(previous stack state)..., capacity, price, slope]}, where the value of `slope' will be on \texttt{[TOS]}.

\pagebreak
\subsubsection{\texttt{VPUSH} --- Push Scalar onto Vector\label{inst:vpush}}

Pushes a scalar onto the $Vector$. 

\noindent \textbf{Notice}

This is gas-efficient in-place operation, as it updates a $Vector$ on \texttt{[TOS]}, appending new component at the end.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{scalar: Scalar} -- Constant $Scalar$ value to be pushed onto $Vector$ at \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len]} -- A $Vector$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len + 1]} -- Resulting $Vector$ of length $len + 1$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     weights_id
    VPUSH   10.0

\end{verbatim}

Load from storage a vector with `weights\_id' ID, and push scalar constant $10.0$ to the end of it.

\textbf{Note} This does not modify the vector in-storage, and only its on-stack copy is modified. To store this modified vector back into storage separate \texttt{STV} instruction is required.


\pagebreak
\subsubsection{\texttt{VPOP} --- Pop Scalar from Vector\label{inst:vpop}}

Pop a scalar from the $Vector$.

\noindent \textbf{Notice}

This is gas-efficient in-place operation, as it updates a $Vector$ on \texttt{[TOS]}, removing its last component.

\noindent \textbf{Operands}

\begin{itemize}
\item \textsl{(no operands)}
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len]} -- A $Vector$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len - 1]} -- Resulting $Vector$ of length $len - 1$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     weights_id
    VPOP

\end{verbatim}

Load from storage a vector with `weights\_id' ID, and pop last element from the end of it.

\textbf{Note} This does not modify the vector in-storage, and only its on-stack copy is modified. To store this modified vector back into storage separate \texttt{STV} instruction is required.

\pagebreak
\subsubsection{\texttt{T} --- Transpose Vectors on Stack\label{inst:t}}

Perform matrix transposition of $M$ vectors on the stack, each of length $N$.

$$
\begin{pmatrix}
    a_{1,1} & a{1,2} & \cdots & a_{1,N} \\
    a_{2,1} & a{2,2} & \cdots & a_{2,N} \\
    \vdots  & \vdots  & \ddots & \vdots \\
    a_{M,1} & a_{M,2} & \cdots & a_{M,N} \\
\end{pmatrix}^{T}
\Rightarrow
\begin{pmatrix}
    a_{1,1} & a{2,1} & \cdots & a_{M,1} \\
    a_{1,2} & a{2,2} & \cdots & a_{M,2} \\
    \vdots  & \vdots  & \ddots & \vdots \\
    a_{1,N} & a_{2,N} & \cdots & a_{M,N} \\
\end{pmatrix}
$$

\noindent \textbf{Notice}

This is gas-efficient in-place operation, which updates $M$ vectors on the stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of vectors on the stack to transpose together.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector} -- A $Vector$ of length `len'.
\item [...]
\item \texttt{[TOS - count]: Vector} -- A $Vector$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector} -- A $Vector$ of length `count'.
\item [...]
\item \texttt{[TOS - len]: Vector} -- A $Vector$ of length `count'.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     index_a_quote_id
    LDV     index_b_quote_id
    LDV     index_c_quote_id
    T       3

\end{verbatim}

Load from vector storage three vectors with IDs: \\

~~~~ \texttt{index\_a\_quote\_id, index\_b\_quote\_id, index\_c\_quote\_id}, \\

and then transpose them into vectors:

\begin{verbatim}
    [index_a_capacity, index_b_capacity, index_c_capacity],
    [index_a_price, index_b_price, index_c_price],
    [index_a_slope, index_b_slope, index_c_slope],
\end{verbatim}

or simply: \\

~~~~ \texttt{capacities}, \texttt{prices}, \texttt{slopes}.


\pagebreak
\subsection{Labels Manipulation (Opcode 40..46)}

\subsubsection{\texttt{LUNION} --- Union of Lables\label{inst:lunion}}

Union of two operands of $Labels$ type.

\noindent \textbf{Notice}

This is gas-efficient in-place operation of complexity $O(N + M)$.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8}: Position on stack of the other $Labels$ object relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Labels} -- The $Labels$ object to be extended.
\item \texttt{[TOS - pos]: Labels} -- The $Labels$ objects containing additional labels.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Resulting $Labels$ object containig original and additional labels.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDL         asset_weights
    LDL         market_asset_weights
    LUNION      1

\end{verbatim}

Load two objects of type $Labels$ from storage with IDs: \texttt{asset\_weights} and \texttt{market\_asset\_weights}, and then modify last labels on \texttt{[TOS]} \textsl{\texttt{market\_asset\_weights}} by adding labels from \texttt{[TOS - 1]} stack level \textsl{\texttt{asset\_weights}}. Resulting labels will contain all original labels from \texttt{market\_asset\_weights} and new labels from \texttt{asset\_weights}.

\pagebreak
\subsubsection{\texttt{LPUSH} --- Push Label onto Labels\label{inst:lpush}}

Pushes a $Label$ onto the $Labels$. 

\noindent \textbf{Notice}

This is gas-efficient in-place operation, as it updates a $Labels$ on \texttt{[TOS]}, appending new component at the end.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{label: Label} -- Constant $Label$ to be pushed onto $Labels$ at \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Labels[0..len]} -- A $Labels$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Labels[0..len + 1]} -- Resulting $Labels$ of length $len + 1$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDL     asset_names_id
    LPUSH   eth_label

\end{verbatim}

Load from storage the labels with `asset\_names\_id' ID, and push label constant `eth\_label' to the end of it.

\textbf{Note} This does not modify the labels in-storage, and only its on-stack copy is modified. To store this modified labels back into storage separate \texttt{STL} instruction is required.

\pagebreak
\subsubsection{\texttt{LPOP} --- Pop Label from Labels\label{inst:lpop}}

Pop a label from the $Labels$.

\noindent \textbf{Notice}

This is gas-efficient in-place operation, as it updates a $Labels$ on \texttt{[TOS]}, removing its last component.

\noindent \textbf{Operands}

\begin{itemize}
\item \textsl{(no operands)}
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Labels[0..len]} -- A $Labels$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Labels[0..len - 1]} -- Resulting $Labels$ of length $len - 1$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDL     asset_names_id
    VPOP

\end{verbatim}

Load from storage the labels with `asset\_names\_id' ID, and pop a label from the end of it.

\textbf{Note} This does not modify the labels in-storage, and only its on-stack copy is modified. To store this modified labels back into storage separate \texttt{STL} instruction is required.


\pagebreak
\subsubsection{\texttt{JUPD} --- Update (Replace) by Joining on Labels\label{inst:jupd}}

Update $Vector$ on top of the stack (\texttt{[TOS]}) by replacing its selected components
with values from another vector on stack at \texttt{[TOS - pos\_B]}
joining on $Labels$.

\noindent \textbf{Notice}

This is an efficient operation of complexity $O(N)$ \textsl{(for contiguous overlaps)}
or $O(N \times \log M)$ \textsl{(for overlaps with gaps)}.


\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos\_B: u8} -- Stack position of $Vector B$ relative to \texttt{[TOS]}.
\item \texttt{lab\_A: u8} -- Stack position of $Labels A$ relative to \texttt{[TOS]}.
\item \texttt{lab\_B: u8} -- Stack position of $Labels B$ relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- Vector A
\item \texttt{[TOS - pos\_B: Vector]} -- Vector B
\item \texttt{[TOS - lab\_A: Labels]} -- Labels A
\item \texttt{[TOS - lab\_B: Labels]} -- Labels B
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]}: -- $Vector A$ updated by replacing values from $Vector B$ mapping them through projection of $Labels B$ onto $Labels A$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    JUPD    2   4   5

\end{verbatim}

Update vector on stack at \texttt{[TOS]} by replacing its selected components with components of a vector at \texttt{[TOS - 2]},
using labels at \texttt{[TOS - 4]} for vector at \texttt{[TOS]}, and
using labels at \texttt{[TOS - 5]} for vector at \texttt{[TOS - 2]},
where labels overlap.

\pagebreak
\subsubsection{\texttt{JADD} --- Add by Joining on Labels\label{inst:jadd}}

Add two $Vectors$ joining on $Labels$. Expands vector at \texttt{[TOS - pos\_B]} using labels at \texttt{[TOS - lab\_B]} 
to match labels of vector at \texttt{TOS} located on stack at \texttt{[TOS - lab\_A]}.

\noindent \textbf{Notice}

This is an efficient operation of complexity $O(N)$ \textsl{(for contiguous overlaps)}
or $O(N \times \log M)$ \textsl{(for overlaps with gaps)}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos\_B: u8} -- Stack position of $Vector B$ relative to \texttt{[TOS]}.
\item \texttt{lab\_A: u8} -- Stack position of $Labels A$ relative to \texttt{[TOS]}.
\item \texttt{lab\_B: u8} -- Stack position of $Labels B$ relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector A$
\item \texttt{[TOS - pos\_B: Vector]} -- $Vector B$
\item \texttt{[TOS - lab\_A: Labels]} -- $Labels A$
\item \texttt{[TOS - lab\_B: Labels]} -- $Labels B$
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]}: -- $Vector A$ updated by adding values from $Vector B$ mapping them through projection of $Labels B$ onto $Labels A$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    JADD    2   4   5

\end{verbatim}

Add to vector on stack at \texttt{[TOS]} selected components of a vector at \texttt{[TOS - 2]},
using labels at \texttt{[TOS - 4]} for vector at \texttt{[TOS]}, and
using labels at \texttt{[TOS - 5]} for vector at \texttt{[TOS - 2]},
where labels overlap.

\pagebreak
\subsubsection{\texttt{JFLT} --- Filter by Joining on Labels\label{inst:jflt}}

Filter vector on stack at \texttt{[TOS]} retaining only components corresponding to labels at \texttt{[TOS - lab\_B]}
using labels at \texttt{[TOS - lab\_A]} for vector at \texttt{[TOS]}, and
where labels overlap.

\noindent \textbf{Notice}

This is an efficient operation of complexity $O(N)$ \textsl{(for contiguous overlaps)}
or $O(N \times \log M)$ \textsl{(for overlaps with gaps)}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{lab\_A: u8} -- Stack position of $Labels A$ relative to \texttt{[TOS]}.
\item \texttt{lab\_B: u8} -- Stack position of $Labels B$ relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector A$
\item \texttt{[TOS - lab\_A: Labels]} -- $Labels A$
\item \texttt{[TOS - lab\_B: Labels]} -- $Labels B$
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]}: -- $Vector A$ filtered by retaining components through projection of $Labels B$ onto $Labels A$.
\end{itemize}   

\noindent \textbf{Usage Example}

\begin{verbatim}

    JFLT    4   5

\end{verbatim}

Filter vector on stack at \texttt{[TOS]} retaining only components corresponding to labels at \texttt{[TOS - 5]}
using labels at \texttt{[TOS - 4]} for vector at \texttt{[TOS]}, and
where labels overlap.

\pagebreak
\subsection{Arithmetic \& Core Math (Opcode 50..55)}

\subsubsection{\texttt{ADD} --- Addition\label{inst:add}}

Add operand at \texttt{[TOS]} to operand at \texttt{[TOS - pos]}.

$$
    [TOS] \leftarrow [TOS] + [TOS - pos]
$$

\noindent \textbf{Notes}

\begin{itemize}
    \item Works with vectors and scalars.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with addition.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of addition.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    5.0
    ADD     1

\end{verbatim}

Add $3.0$ to $5.0$, and replace $5.0$ with result of the addition ($8.0$).

\pagebreak
\subsubsection{\texttt{SUB} --- Substraction\label{inst:sub}}

Subtract from operand at \texttt{[TOS]} an operand at \texttt{[TOS - pos]}.

\noindent \textbf{Notes}

\begin{itemize}
    \item Works with vectors and scalars.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}


\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with subtraction.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of subtraction.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    5.0
    SUB     1

\end{verbatim}

Subtract $3.0$ from $5.0$, and replace $5.0$ with result of the subtraction ($2.0$).

\pagebreak
\subsubsection{\texttt{SSB} --- Saturating Subraction\label{inst:ssb}}

Subtract from operand at \texttt{[TOS]} an operand at \texttt{[TOS - pos]} saturating to $0$.

$$
    [TOS] \leftarrow \max([TOS] - [TOS - pos], 0)
$$

\noindent \textbf{Notes}

\begin{itemize}
    \item Works with vectors and scalars.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}


\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with saturating subtraction.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of saturating subtraction.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    5.0
    IMMS    3.0
    SSB     1

\end{verbatim}

Subtract $5.0$ from $3.0$ saturating at $0.0$, and replace $3.0$ with result of the saturating subtraction ($0.0$).

\pagebreak
\subsubsection{\texttt{MUL} --- Multiplication\label{inst:mul}}

Multiply operand at \texttt{[TOS]} by operand at \texttt{[TOS - pos]}.

$$
    [TOS] \leftarrow [TOS] \odot [TOS - pos]
$$

\noindent \textbf{Notes}

\begin{itemize}
    \item Works with vectors and scalars.
    \item Multiplication of two vectors is performed component-wise.
    \item Multiplication of vector by scalar is possible, but not scalar by vector as it is an in-place operation.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with multiplication.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of multiplication.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    5.0
    MUL     1

\end{verbatim}

Multiply $3.0$ by $5.0$, and replace $5.0$ with result of the multiplication ($15.0$).

\pagebreak
\subsubsection{\texttt{DIV} --- Division\label{inst:div}}

Divide operand at \texttt{[TOS]} by operand at \texttt{[TOS - pos]}.

$$
    [TOS] \leftarrow \frac{ [TOS] }{ [TOS - pos] }
$$

\noindent \textbf{Notes}

\begin{itemize}
    \item Works with vectors and scalars.
    \item Division of two vectors is performed component-wise.
    \item Division of vector by scalar is possible, but not scalar by vector as it is an in-place operation.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with division.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of division.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    15.0
    DIV     1

\end{verbatim}

Divide $15.0$ by $3.0$, and replace $15.0$ with result of the multiplication ($3.0$).

\pagebreak
\subsubsection{\texttt{SQRT} --- Square Root\label{inst:sqrt}}

Take square root of \texttt{[TOS]}.

$$
    [TOS] \leftarrow \sqrt{[TOS]}
$$

\noindent \textbf{Note}
\begin{itemize}
    \item Works with vectors and scalars. 
    \item Square root of two vector is performed component-wise.
    \item In-place updates operand on TOS.
\end{itemize}

\noindent \textbf{Notice}

This operation is implemented using \textsl{Babylonian method} of $O(\log k)$ complexity where $k$ is number of bits.
Since it is fixed point $128$-bit number, this is constant $O(1)$.

\noindent \textbf{Operands}

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand of square root.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Result of square root.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    4.0
    SQRT

\end{verbatim}

Take square root of $4.0$, and replace $4.0$ with the result ($2.0$).

\pagebreak
\subsection{Logic \& Comparison (Opcode 60..61)}

\subsubsection{\texttt{MIN} --- Minimum\label{inst:min}}

Take minimum between operand at \texttt{[TOS]} and operand at \texttt{[TOS - pos]}.

$$
    [TOS] \leftarrow \min{( [TOS], [TOS - pos] )}
$$

\noindent \textbf{Notes}

\begin{itemize}
    \item Works with vectors and scalars.
    \item Minimum of two vectors is performed component-wise.
    \item Minimum of vector by scalar is possible, but not scalar by vector as it is an in-place operation.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with minimum.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of minimum.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    5.0
    MIN     1

\end{verbatim}

Take minimum of $5.0$ and $3.0$, and replace $5.0$ with result of the minimum ($3.0$).

\subsubsection{\texttt{MAX} --- Maximum\label{inst:max}}

Take maximum between operand at \texttt{[TOS]} and operand at \texttt{[TOS - pos]}.

$$
    [TOS] \leftarrow \max{( [TOS], [TOS - pos] )}
$$

\noindent \textbf{Notes}

\begin{itemize}
    \item Works with vectors and scalars.
    \item Maximum of two vectors is performed component-wise.
    \item Maximum of vector by scalar is possible, but not scalar by vector as it is an in-place operation.
    \item In-place updates operand on \texttt{[TOS]}.
    \item Does not consume the other operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector|Scalar]} -- Operand to be updated in-place, with maximum.
\item \texttt{[TOS - pos: Vector|Scalar]} -- Second operand of maximum.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Updated first operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    3.0
    IMMS    5.0
    MAX     1

\end{verbatim}

Take minimum of $5.0$ and $3.0$, and replace $5.0$ with result of the minimum ($5.0$).


\pagebreak
\subsection{Vector Aggregation (Opcode 70..72)}

\subsubsection{\texttt{VSUM} --- Sum of Vector components\label{inst:vsum}}

Sum of all vector components.

$$
    [TOS] \leftarrow \sum_{i=0}^{len([TOS])} \left( [TOS][i] \right)
$$

\noindent \textbf{Operands}

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector$ of which components to sum.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Scalar]} -- $Scalar$ sum of input vector components.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     asset_weights_id
    VSUM

\end{verbatim}

Load from storage a $Vector$ with ID `asset\_weights\_id', and compute sum of all components,
i.e. sum of all weights, and place result on \texttt{[TOS]}.

\pagebreak
\subsubsection{\texttt{VMIN} --- Minimum component of a Vector\label{inst:vmin}}

Minimum value found within vector components.

$$
    [TOS] \leftarrow \min_{i=0}^{len([TOS])} \left( [TOS][i] \right)
$$

\noindent \textbf{Operands}

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector$ of which components minimum to find.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Scalar]} -- $Scalar$ minium of input vector components.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     asset_weights_id
    VMIN

\end{verbatim}

Load from storage a $Vector$ with ID `asset\_weights\_id', find minimum weight, and place result on \texttt{[TOS]}.


\pagebreak
\subsubsection{\texttt{VMAX} --- Maximum component of a Vector\label{inst:vmax}}

Maximum value found within vector components.

$$
    [TOS] \leftarrow \max_{i=0}^{len([TOS])} \left( [TOS][i] \right)
$$

\noindent \textbf{Operands}

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector$ of which components maximum to find.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Scalar]} -- $Scalar$ maximum of input vector components.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     asset_weights_id
    VMAX

\end{verbatim}

Load from storage a $Vector$ with ID `asset\_weights\_id', find maximum weight, and place result on \texttt{[TOS]}.


\pagebreak
\subsection{Immediate Values \& Vector Creation (Opcode 80..83)}

\subsubsection{\texttt{IMMS} --- Push Scalar on Stack\label{inst:imms}}

Push immediate $Scalar$ value on stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{value: Scalar} -- Constant $Scalar$ value to be pushed on stack.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Scalar]} -- $Scalar$ operand pushed.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    4.0

\end{verbatim}

Push constant value $4.0$ on \texttt{[TOS]}.

\pagebreak
\subsubsection{\texttt{IMML} --- Push Label on Stack\label{inst:imml}}

Push immediate $Label$ value on stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{value: Label} -- Constant $Label$ value to be pushed on stack.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Label]} -- $Label$ operand pushed.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMML    btc_label

\end{verbatim}

Push constant label value `btc\_label' from Rust code onto stack.

\pagebreak
\subsubsection{\texttt{ZEROS} --- Zero Vector\label{inst:zeros}}

Create Vector of zeros matching length of the operand at \texttt{[TOS - pos]}.

\noindent \textbf{Notes}
\begin{itemize}
    \item Works for $Vector$ and $Labels$ type of operands.
    \item Pushes new zero $Vector$ on \texttt{[TOS]}.
    \item Does not consume the operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos}: \texttt{u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS - pos: Vector|Labels]} -- $Vector$ or $Labels$ the length of which to use.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector$ of zeros with same length as input operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDL     asset_names_id
    ZEROS   1

\end{verbatim}

Load from storage $Labels$ with ID `asset\_names\_id', and then create zero $Vector$ of same length.

\pagebreak
\subsubsection{\texttt{ONES} --- Unit Vector\label{inst:ones}}

Create Vector of ones matching length of the operand at \texttt{[TOS - pos]}.

\noindent \textbf{Notes}
\begin{itemize}
    \item Works for $Vector$ and $Labels$ type of operands.
    \item Pushes new unit $Vector$ on \texttt{[TOS]}.
    \item Does not consume the operand.
\end{itemize}

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos}: \texttt{u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS - pos: Vector|Labels]} -- $Vector$ or $Labels$ the length of which to use.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- Unit $Vector$ with same length as input operand.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDL     asset_names_id
    ONES    1

\end{verbatim}

Load from storage $Labels$ with ID `asset\_names\_id', and then create unit $Vector$ of same length.


\pagebreak
\subsection{Stack Control \& Program Flow (Opcode 90..94)}

\subsubsection{\texttt{POPN} --- Pop N levels from Stack\label{inst:popn}}

Pop $count$ values from the stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of levels to pop.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- First level to pop from stack.
\item \texttt{[...]}
\item \texttt{[TOS - count]}: Last level to pop from stack.
\item \textsl{(rest of stack...)}
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(rest of stack...)}
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    1.0
    IMMS    2.0
    IMMS    3.0
    IMMS    4.0
    POPN    3

\end{verbatim}

Pop $3$ levels from stack, i.e. poped elements are \textsl{2.0, 3.0, 4.0}, leaving $1.0$ on stack at \texttt{[TOS]}.

\pagebreak
\subsubsection{\texttt{SWAP} --- Swap levels on Stack\label{inst:swap}}

Swap TOS with operand at \texttt{[TOS - pos]}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- First level to swap.
\item \texttt{[...]}
\item \texttt{[TOS - pos]}: Second level to swap.
\item \textsl{(rest of stack...)}
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Operand from previously second level.
\item \texttt{[...]}
\item \texttt{[TOS - pos]}: Operand from previously first level.
\item \textsl{(rest of stack...)}
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS    1.0
    IMMS    2.0
    IMMS    3.0
    IMMS    4.0
    SWAP    2

\end{verbatim}

Swap $4.0$ with $2.0$, which results in stack \texttt{[1.0, 4.0, 3.0, 2.0]}, where $2.0$ is at \texttt{[TOS]}.

\pagebreak
\subsubsection{\texttt{B} --- Branch into stored procedure\label{inst:b}}

Call sub-routine stored as $Code$ at `prg\_id`, supplying `N` inputs and taking `M` outputs from stack. 

The `N` inputs are consumed from stack. `M` outputs are moved from sub-routine's \texttt{[TOS]} to caller's \texttt{[TOS]}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{prg\_id: u128} -- An $ID$ of the stored procedure $Code$ object in vector storage.
\item \texttt{N: u8} -- Number of arguments to move from our stack to stack of the stored procedure before its execution.
\item \texttt{M: u8} -- Number of returned values to move back from stack of the stored procedure after its execution.
\item \texttt{R: u8} -- Number of registers to allocate for stored procedure before its execution.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Last argument
\item \texttt{[...]}
\item \texttt{[TOS - N]} -- First argument
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Last returned value
\item \texttt{[...]}
\item \texttt{[TOS - M]} -- First returned value
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDR         _Slope
    LDR         _Price
    LDR         _Collateral
    B           solve_quadratic_id  3  1  4
    STR         _IndexQuantity

\end{verbatim}

Load from registry `\_Slope', `\_Price', and `\_Collateral', and pass them as arguments to function
loaded from storage with ID `solve\_quadratic\_id'. Function returns single value, which we store into
registry as `\_IndexQuantity'.

\pagebreak
\subsubsection{\texttt{FOLD} --- Apply stored procedure to all components\label{inst:fold}}

Fold (iterate) over vector/label operands.

The behaviour of the operation is the same as \texttt{B} except sub-routine is called repeatedly over components of Vector at \texttt{[TOS]}.

\noindent \textbf{Notice}

This is gas-efficient method of innovation of stored procedure multiple times for batch of items.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{prg\_id: u128} -- An $ID$ of the stored procedure $Code$ object in vector storage.
\item \texttt{N: u8} -- Number of arguments to move from our stack to stack of the stored procedure before its execution.
\item \texttt{M: u8} -- Number of returned values to move back from stack of the stored procedure after its execution.
\item \texttt{R: u8} -- Number of registers to allocate for stored procedure before its execution.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector|Labels} -- Iterable object of type $Vector$ or $Labels$.
\item \texttt{[TOS - 1]} -- Last argument
\item \texttt{[...]}
\item \texttt{[TOS - N - 1]} -- First argument
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Last returned value
\item \texttt{[...]}
\item \texttt{[TOS - M]} -- First returned value
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    FOLD    prg_id  N   M   R

\end{verbatim}



\end{document}