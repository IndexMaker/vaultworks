% !TEX program = lualatex
\documentclass[11pt, a4paper]{article}

% --- UNIVERSAL PREAMBLE BLOCK ---
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}
\usepackage{fontspec}
\usepackage{booktabs} % For professional-looking tables
\usepackage{longtable} % For tables that span multiple pages
\usepackage{amsmath} % For math environments
\usepackage{xcolor} % For colors
\usepackage{listings} % For code snippets
\usepackage{hyperref} % Always load last
\usepackage{graphicx}

\usepackage[english, bidi=basic, provide=*]{babel}
\babelprovide[import, onchar=ids fonts]{english}

% Set default/Latin font to Sans Serif in the main (rm) slot
\babelfont{rm}{Noto Sans}
% --- END UNIVERSAL PREAMBLE BLOCK ---

\title{\textbf{Vector Intermediate Language (VIL) \\
\large Gas-Efficient Vector VM as a Smart-Contract in Rust / Stylus (WASM)}}
\author{Sonia Kolasinska}
\date{\today}

\begin{document}
\maketitle
\thispagestyle{empty} % Suppress page number on the title page
\setlength{\parskip}{0.8em}
\setlength{\parindent}{0em}

\vspace{1cm}

\pagebreak
\section{Introduction: The VM$^2$ Architecture}

The Vector ---  Language (VIL) Virtual Machine represents a modern approach to deploying complex mathematical and financial logic onto the Arbitrum ecosystem using Rust / Stylus.

This architecture is a \emph{VM$^2$}---a Virtual Machine (VIL) running as a smart contract within Virtual Machine (WASM, hosted by Arbitrum node).

\subsection{Motivation: Gas Efficiency through On-Chain Vector Operations}

The primary innovation of VIL is the substantial gas savings realized by relocating complex vector algebra directly into the smart contract's state and execution context.

In traditional EVM smart contract systems, performing vector operations often requires:
\begin{enumerate}
    \item Loading raw data from storage (\texttt{SLOAD}).
    \item Storing raw data into storage (\texttt{SSTORE}).
    \item (De)Serializing structured data (e.g. \texttt{Vec<u128>}) between contract calls.
    \item Passing large data arrays as call data, incurring significant calldata gas costs.
    \item Executing memory-intensive loops in the EVM, which is highly gas-inefficient for array processing.
\end{enumerate}

\textbf{VIL eliminates these bottlenecks:}

\begin{itemize}
    \item \textbf{Zero Serialization Overhead:} Vector data, stored as a pure binary blob (\texttt{Vec<Amount>}; where \texttt{Amount} is \texttt{u128} wrapper type), is loaded directly into the VIL execution environment within the same smart contract. All vector operations (addition, subtraction, multiplication, etc.) happen purely within the VIL execution context, \textbf{avoiding expensive EVM-based serialization and ABI encoding/decoding between logic steps}.
    \item \textbf{Optimal Data Flow:} Data is loaded \textbf{once} from a single storage slot (\texttt{SLOAD}), processed entirely, and stored back once (\texttt{SSTORE}), maximizing efficiency within the WASM environment.
    \item \textbf{WASM Optimization:} By executing the core logic via a simple, specialized instruction set (VIL), the underlying WASM runtime can execute vector mathematics far more efficiently than general-purpose EVM bytecode.
\end{itemize}

\pagebreak
\section{Development Workflow with the \texttt{devil!()} Proc Macro}

Writing raw instruction bytes and operands for any VM is tedious and error-prone. The \texttt{devil!()} procedural macro simplifies VIL program creation by allowing developers to embed native VIL assembly code directly within Rust functions.

\subsection{Macro Functionality}

The \texttt{devil!()} macro transpiles the human-readable VIL assembly language into an efficient, executable bytecode array (\texttt{Vec<u8>}). This allows for:

\begin{itemize}
    \item \textbf{Readability:} Programs are easy to audit and maintain.
    \item \textbf{Type Safety:} The underlying Rust environment ensures correct operand types (e.g., \texttt{u128} storage IDs, registry names) are used.
    \item \textbf{Concise Syntax:} Eliminates the need for manual byte array construction.
\end{itemize}

\subsection{Usage Example}

The following snippet demonstrates how a complex sequence of data retrieval and vector operations is expressed concisely using the macro:

\begin{verbatim}
use devil_macros::devil;

pub fn execute_buy_order(...) -> Vec<u8> {
    devil! {
        LDV         asset_weights_id                // Load from Blockchain (SLOAD)
        STR         _Weights                        // Store into registry
        // ...

        LDR         _CappedIndexQuantity            // Load from registry
        LDM         _Weights                        // Move from registry
        MUL         1                               // Multiply
        // ...

        LDM         _AssetQuantities                // Move from registry
        STV         executed_asset_quantities_id    // Store into Blockchain (SSTORE)
    }
}
\end{verbatim}

\pagebreak
\section{VIL Instruction Set Reference}

The VIL instruction set is designed around the concept of a stack machine operating on two primary data types: \textbf{Scalar} (\texttt{Amount}) and \textbf{Vector} (\texttt{Vec<Amount>}), and additionally \textbf{Labels} (\texttt{Vec<u128>}), which enable \textsl{Join} operations (e.g. \texttt{JADD}, \texttt{JUPD}, \texttt{JFLT}). The instructions manipulate the stack and the internal registry (\texttt{R0}...\texttt{Rn}).

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{VIL_Stack.jpg}\label{fig:stack_arch}
    \caption{Conceptual VIL VM Stack and Data Flow.}
\end{figure}

\subsection*{Instruction Set Quick Reference}
\addcontentsline{toc}{subsection}{---  Set Quick Reference}
Quick listing of instructions.


\begin{longtable}{p{0.15\linewidth} p{0.75\linewidth}}
\caption{VIL ---  Set Summary}\label{tab:vil_summary}\\
\toprule
\textbf{Mnemonic} & \textbf{Brief Description} \\
\midrule
\endfirsthead
\multicolumn{2}{c}%
{\tablename\ \thetable\ -- Continued from previous page} \\
\toprule
\textbf{Mnemonic} & \textbf{Brief Description} \\
\midrule
\endhead
\bottomrule
\endfoot
\bottomrule
\endlastfoot
\hyperlink{inst:ldl}{\texttt{LDL}} & Load Labels object from VIO by ID. Pushes on TOS.. \\
\hyperlink{inst:ldv}{\texttt{LDV}} & Load Vector object from VIO by ID. Pushes on TOS.. \\
\hyperlink{inst:ldd}{\texttt{LDD}} & Load Duplicate (copy) of stack operand at $[T-pos]$. Pushes on TOS.. \\
\hyperlink{inst:ldr}{\texttt{LDR}} & Load value from Registry (R0-Rn). Pushes on TOS.. \\
\hyperlink{inst:ldm}{\texttt{LDM}} & Load value moving it out of Registry (R0-Rn). Value is removed from registry. Pushes on TOS.. \\
\hyperlink{inst:stl}{\texttt{STL}} & Store Labels object into VIO. Consumes TOS.. \\
\hyperlink{inst:stv}{\texttt{STV}} & Store Vector object into VIO. Consumes TOS.. \\
\hyperlink{inst:str}{\texttt{STR}} & Store into Registry (R0-Rn). Consumes TOS.. \\
\hyperlink{inst:pkv}{\texttt{PKV}} & Pack `count` values from stack into a new Vector. Consumes `count` operands from TOS, and replaces them with Vector.. \\
\hyperlink{inst:pkl}{\texttt{PKL}} & Pack `count` values from stack into a new Labels object. Consumes `count` operands from TOS, and replaces them with Labels.. \\
\hyperlink{inst:unpk}{\texttt{UNPK}} & Unpack a Vector/Labels object onto the stack. Consumes TOS, and replaces with its components.. \\
\hyperlink{inst:vpush}{\texttt{VPUSH}} & Push a scalar onto the Vector (TOS). In-place updates Vector on TOS, appending new component at the end.. \\
\hyperlink{inst:vpop}{\texttt{VPOP}} & Pop a scalar from the Vector (TOS). In-place updates Vector on TOS, removing last component.. \\
\hyperlink{inst:t}{\texttt{T}} & Transpose `count` vectors on stack $[V1, V2]$ -> $[T1, T2]$. In-place updates `count` operands from TOS by performing transform.. \\
\hyperlink{inst:lunion}{\texttt{LUNION}} & Union of two Labels operands (TOS and T-pos). Pushes on TOS.. \\
\hyperlink{inst:lpush}{\texttt{LPUSH}} & Push a label value onto the Labels object (TOS). In-place updates Labels on TOS, appending new component at the end.. \\
\hyperlink{inst:lpop}{\texttt{LPOP}} & Pop a label value from the Labels object (TOS). In-place updates Labels on TOS, removing last component.. \\
\hyperlink{inst:jupd}{\texttt{JUPD}} & Update using Labels. Expands vector at $[TOS - pos\_B]$ using labels at $[TOS - lab\_B]$ to match labels of TOS at $[TOS - lab\_A]$. In-place updates TOS. Consumes TOS.. \\
\hyperlink{inst:jadd}{\texttt{JADD}} & Add using Labels. Expands vector at $[TOS - pos\_B]$ using labels at $[TOS - lab\_B]$ to match labels of TOS at $[TOS - lab\_A]$. In-place updates TOS. Consumes TOS.. \\
\hyperlink{inst:jflt}{\texttt{JFLT}} & Filter using Labels. Expands vector at $[TOS-1]$ using labels at $[T-lab\_B]$ to match labels of TOS at $[T-lab\_A]$. In-place updates TOS. Does not consume other operands.. \\
\hyperlink{inst:add}{\texttt{ADD}} & Add TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:sub}{\texttt{SUB}} & Subtract TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:ssb}{\texttt{SSB}} & Saturating subtract TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:mul}{\texttt{MUL}} & Multiply TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:div}{\texttt{DIV}} & Divide TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:sqrt}{\texttt{SQRT}} & Square root of TOS (scalar or component-wise vector). Works with vectors and scalars. In-place updates operand on TOS.. \\
\hyperlink{inst:min}{\texttt{MIN}} & Min between TOS and operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:max}{\texttt{MAX}} & Max between TOS and operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.. \\
\hyperlink{inst:vsum}{\texttt{VSUM}} & Sum of all vector components. Pushes on TOS. Does not consume the operand.. \\
\hyperlink{inst:vmin}{\texttt{VMIN}} & Minimum value found within vector components. Pushes on TOS. Does not consume the operand.. \\
\hyperlink{inst:vmax}{\texttt{VMAX}} & Maximum value found within vector components. Pushes on TOS. Does not consume the operand.. \\
\hyperlink{inst:imms}{\texttt{IMMS}} & Push immediate Scalar value on stack. \\
\hyperlink{inst:imml}{\texttt{IMML}} & Push immediate Label value on stack. \\
\hyperlink{inst:zeros}{\texttt{ZEROS}} & Create Vector of zeros matching length of Labels at $[T-pos]$. Pushes on TOS. Does not consume the operand.. \\
\hyperlink{inst:ones}{\texttt{ONES}} & Create Vector of ones matching length of Labels at $[T-pos]$. Pushes on TOS. Does not consume the operand.. \\
\hyperlink{inst:popn}{\texttt{POPN}} & Pop 'n' values from the stack. \\
\hyperlink{inst:swap}{\texttt{SWAP}} & Swap TOS with operand at $[T-n]$. \\
\hyperlink{inst:b}{\texttt{B}} & Call sub-routine stored as Labels at `prg\_id`, supplying `N` inputs and taking `M` outputs from stack. `N` inputs are consumed from stack. `M` outputs are moved from sub-routine's TOS to caller's TOS.. \\
\hyperlink{inst:fold}{\texttt{FOLD}} & Fold (iterate) over vector/label operands. Same as `B` except sub-routine is called repeatedly over components of Vector at TOS.. \\
\end{longtable}




\vspace{0.5cm} % Add some space after the table

\pagebreak
\subsection{1. Data Loading \& Stack Access (Opcode 10..15)}

\subsubsection{\texttt{LDL} --- Load Labels from Storage\label{inst:ldl}}

Load (\texttt{Labels}) object by $ID$ from \textsl{Vector I/O (VIO)}.

\noindent \textbf{Notice}

This is relatively gas-expensive operation as it will load binary blob from \textsl{Blockchain} using underlying \texttt{(SLOAD)} operatation.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{labels\_id: u128} -- An $ID$ of the $Labels$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Labels} -- $Labels$ object loaded from vector storage.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}
    LDL     asset_names_id
\end{verbatim}

Load $Labels$ with `asset\_names\_id' ID from vector storage.


\subsubsection{\texttt{LDV} --- Load Vector from Storage\label{inst:ldv}}

Load (\texttt{Vector}) object by $ID$ from \textsl{Vector I/O (VIO)}.

\noindent \textbf{Notice}

This is relatively gas-expensive operation as it will load binary blob from \textsl{Blockchain} using underlying \texttt{(SLOAD)} operatation.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{labels\_id: u128} -- An $ID$ of the $Vector$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector} -- $Vector$ object loaded from vector storage.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     asset_weights_id

\end{verbatim}

Load $Vector$ with `asset\_weights\_id' ID from vector storage.

\subsubsection{\texttt{LDD} --- Load Duplicate from Stack\label{inst:ldd}}

Load duplicate (copy) of stack operand at \texttt{T - pos}.

\noindent \textbf{Notice}

This is mildly gas-expensive operation, much less gas-expensive than load from
vector storage, but still it requires cloning of a vector.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos: u8} -- Stack position relative to \texttt{TOS} from where we want to duplicate an operand.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS - pos]} -- Source operand to be cloned.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Duplicate of the operand at \texttt{TOS - pos}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDD     3

\end{verbatim}

Create a duplicate of the operand three levels deep on the stack.

\subsubsection{\texttt{LDR} --- Load Duplicate from Registry \label{inst:ldr}}

Load duplicate (copy) from registry \texttt{reg}.

\noindent \textbf{Notice}

This is mildly gas-expensive operation, much less gas-expensive than load from
vector storage, but still it requires cloning of a vector.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{reg: u8} -- Register number \texttt{0..num\_registry}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Duplicate of the registry \texttt{reg}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDR     _AssetWeights

\end{verbatim}

Create a duplicate of the register allocated for \texttt{\_AssetWeights}.

The \texttt{\_AssetWeights} is a convenience label we associate with some register when we use \texttt{devil!()} macro.

\subsubsection{\texttt{LDM} --- Load Moving from Register\label{inst:ldm}}

Load value moving it out of registry \texttt{reg}.

\noindent \textbf{Notice}

This is highly gas-effective operation, as operand is moved from register onto stack without copying.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{reg: u8} -- Register number \texttt{0..num\_registry}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \textsl{(no stack args)}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- Value moved out of the registry \texttt{reg}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDM     _MarketAssetPrices

\end{verbatim}

Move \texttt{\_MarketAssetPrices} value out of register, and place it on stack.

The \texttt{\_MarketAssetPrices} is a convenience label we associate with some register when we use \texttt{devil!()} macro.

\pagebreak
\subsection{2. Data Storage \& Register Access (Opcode 20..23)}

\subsubsection{\texttt{STL} --- Store Labels into Storage\label{inst:stl}}

Store (\texttt{Labels}) object by $ID$ into \textsl{Vector I/O (VIO)}.

\noindent \textbf{Notice}

This is relatively gas-expensive operation as it will store binary blob into \textsl{Blockchain} using underlying \texttt{(SSTORE)} operatation.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{labels\_id: u128} -- An $ID$ of the $Labels$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Operand on stack to be moved into vector storage \texttt{labels\_id}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    STL     market_asset_names_id

\end{verbatim}

Pop value from stack \texttt{[TOS]} and store it into vector storage with  `market\_asset\_names' ID.


\subsubsection{\texttt{STV} --- Store Vector into Storage\label{inst:stv}}

Store (\texttt{Vector}) object by $ID$ into \textsl{Vector I/O (VIO)}.

\noindent \textbf{Notice}

This is relatively gas-expensive operation as it will store binary blob into \textsl{Blockchain} using underlying \texttt{(SSTORE)} operatation.


\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{vector\_id: u128} -- An $ID$ of the $Vector$ object \textsl{(vector storage slot)}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Operand on stack to be moved into vector storage \texttt{vector\_id}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    STV     market_asset_prices

\end{verbatim}

Pop value from stack \texttt{[TOS]} and store it into vector storage with  `market\_asset\_prices' ID.

\subsubsection{\texttt{STR} --- Store Moving into Registry\label{inst:str}}

Move value from stack and store it into registry \texttt{reg}.

\noindent \textbf{Notice}

This is highly gas-effective operation, as operand is moved from stack into register without copying.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{reg: u8} -- Register number \texttt{0..num\_registry}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]} -- Operand on stack to be moved into registry \texttt{reg}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    STR     _AssetWeights

\end{verbatim}

Pop value from stack \texttt{[TOS]} and store it in register allocated for  \texttt{\_AssetWeights}.

\pagebreak
\subsection{3. Data Structure Manipulation (Opcode 30..35)}

\subsubsection{\texttt{PKV} --- Pack Scalar values into Vector\label{inst:pkv}}

Pack \texttt{count} $Scalar$ type values from stack into a new $Vector$.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of stack levels starting from \texttt{[TOS]} that we want to pack into $Vector$.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Scalar} -- Operand on stack to be packed as last element of resulting $Vector$.
\item [...]
\item \texttt{[TOS - count]: Scalar} -- Operand on stack to be packed as first element of resulting $Vector$.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- $Vector$ contructed from stack operands \texttt{[TOS - count], ..., [TOS]}
\item \textsl{(stack shifted by `count' levels)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDR     _Capacity
    LDR     _Price
    LDR     _Slope
    PKV     3

\end{verbatim}

Load three values from registry: \texttt{\_Capacity}, \texttt{\_Price}, \texttt{\_Slope}, and then pack them into single $Vector$: \texttt{[\_Capacity, \_Price, \_Slope]}.

\subsubsection{\texttt{PKL} --- Pack Label values into Labels object\label{inst:pkl}}

Pack \texttt{count} $Label$ type values from stack into a new $Labels$.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of stack levels starting from \texttt{[TOS]} that we want to pack into $Labels$.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Label} -- Operand on stack to be packed as last element of resulting $Labels$.
\item [...]
\item \texttt{[TOS - count]: Label} -- Operand on stack to be packed as first element of resulting $Labels$.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]} -- $Labels$ contructed from stack operands \texttt{[TOS - count], ..., [TOS]}
\item \textsl{(stack shifted by `count' levels)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMML    btc_label
    IMML    eth_label
    IMML    xrp_label
    PKL     3

\end{verbatim}

Load three $Label$ constants: \texttt{btc\_label}, \texttt{eth\_label}, \texttt{xrp\_label}, and then pack them into single $Labels$: \texttt{[btc\_label, eth\_label, xrp\_label]}.


\subsubsection{\texttt{UNPK} --- Unpack values from Vector / Labels\label{inst:unpk}}

Unpack a $Vector$ / $Labels$ object onto the stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \textsl{(no operands)}
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector|Labels} -- An object to be unpacked onto stack $Vector$ / $Labels$: \texttt{[[0], ..., [count - 1]]}.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Scalar|Label} -- Component unpacked as last from $Vector$ / $Labels$.
\item [...]
\item \texttt{[TOS - count]: Scalar|Label} -- Component unpacked as first from $Vector$ / $Labels$.
\item \textsl{(stack shifted by one level)}.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     index_quote_id
    UNPK

\end{verbatim}

Load a $Vector$ from vector storage with `index\_quote\_id' ID, and unpack its components onto stack. Given that `index\_quote\_id' points to a vector, the component of which are: \texttt{[capacity, price, slope]}, the resulting stack will have structure: \texttt{[(previous stack state)..., capacity, price, slope]}, where the value of `slope' will be on \texttt{[TOS]}.

\subsubsection{\texttt{VPUSH} --- Push Scalar onto Vector\label{inst:vpush}}

Pushes a scalar onto the $Vector$. 

\noindent \textbf{Notice}

This is gas-efficient in-place operation, as it updates a $Vector$ on \texttt{[TOS]}, appending new component at the end.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{scalar: Scalar} -- Constant $Scalar$ value to be pushed onto $Vector$ at \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len]} -- A $Vector$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len + 1]} -- Resulting $Vector$ of length $len + 1$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     weights_id
    VPUSH   10.0

\end{verbatim}

Load from storage a vector with `weights\_id' ID, and push scalar constant $10.0$ to the end of it.

\textbf{Note} This does not modify the vector in-storage, and only its on-stack copy is modified. To store this modified vector back into storage separate \texttt{STV} instruction is required.


\subsubsection{\texttt{VPOP} --- Pop Scalar from Vector\label{inst:vpop}}

Pop a scalar from the $Vector$.

\noindent \textbf{Notice}

This is gas-efficient in-place operation, as it updates a $Vector$ on \texttt{[TOS]}, removing its last component.

\noindent \textbf{Operands}

\begin{itemize}
\item \textsl{(no operands)}
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len]} -- A $Vector$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector[0..len - 1]} -- Resulting $Vector$ of length $len - 1$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    STL     weights_id
    VPOP

\end{verbatim}

Load from storage a vector with `weights\_id' ID, and pop last element from the end of it.

\textbf{Note} This does not modify the vector in-storage, and only its on-stack copy is modified. To store this modified vector back into storage separate \texttt{STV} instruction is required.

\subsubsection{\texttt{T} --- Transpose Vectors on Stack\label{inst:t}}

Perform matrix transposition of $M$ vectors on the stack ,each of length $N$.

$$
\begin{pmatrix}
    a_{1,1} & a{1,2} & \cdots & a_{1,N} \\
    a_{2,1} & a{2,2} & \cdots & a_{2,N} \\
    \vdots  & \vdots  & \ddots & \vdots \\
    a_{M,1} & a_{M,2} & \cdots & a_{M,N} \\
\end{pmatrix}^{T}
\Rightarrow
\begin{pmatrix}
    a_{1,1} & a{2,1} & \cdots & a_{M,1} \\
    a_{1,2} & a{2,2} & \cdots & a_{M,2} \\
    \vdots  & \vdots  & \ddots & \vdots \\
    a_{1,N} & a_{2,N} & \cdots & a_{M,N} \\
\end{pmatrix}
$$

\noindent \textbf{Notice}

This is gas-efficient in-place operation, which updates $M$ vectors on the stack.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{count: u8} -- Number of vectors on the stack to transpose together.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS]: Vector} -- A $Vector$ of length `len'.
\item [...]
\item \texttt{[TOS - count]: Vector} -- A $Vector$ of length `len'.
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS]: Vector} -- A $Vector$ of length `count'.
\item [...]
\item \texttt{[TOS - len]: Vector} -- A $Vector$ of length `count'.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LDV     index_a_quote_id
    LDV     index_b_quote_id
    LDV     index_c_quote_id
    T       3

\end{verbatim}

Load from vector storage three vectors with IDs: \\

~~~~ \texttt{index\_a\_quote\_id, index\_b\_quote\_id, index\_c\_quote\_id}, \\

and then transpose them into vectors:

\begin{verbatim}
    \texttt{[index\_a\_capacity, index\_b\_capacity, index\_c\_capacity]}, \\
    \texttt{[index\_a\_price, index\_b\_price, index\_c\_price]}, \\
    \texttt{[index\_a\_slope, index\_b\_slope, index\_c\_slope]}, \\
\end{verbatim}

or simply: \\

~~~~ \texttt{capacities}, \texttt{prices}, \texttt{slopes}.


\pagebreak
\subsection{4. Labels Manipulation (Opcode 40..46)}

\subsubsection{\texttt{LUNION} --- \label{inst:lunion}}

Union of two Labels operands (TOS and T-pos). Pushes on TOS.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos, TOS]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LUNION <pos>

\end{verbatim}

\subsubsection{\texttt{LPUSH} --- \label{inst:lpush}}

Push a label value onto the Labels object (TOS). In-place updates Labels on TOS, appending new component at the end.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<immediate}: \texttt{u128} Stack pos
\item \texttt{(label)>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS: Labels[0..len]$]}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS:Labels[0..len + 1]$]}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LPUSH <immediate (label)>

\end{verbatim}

\subsubsection{\texttt{LPOP} --- \label{inst:lpop}}

Pop a label value from the Labels object (TOS). In-place updates Labels on TOS, removing last component.

\noindent \textbf{Operands}

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS: Labels[0..len]$]}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS: Labels[0..len - 1]$]}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    LPOP

\end{verbatim}

\subsubsection{\texttt{JUPD} --- Update (Replace) by Joining on Labels\label{inst:jupd}}

Update $Vector$ on top of the stack (\texttt{[TOS]}) by replacing its selected components
with values from another vector on stack at \texttt{[TOS - pos\_B]}
joining on $Labels$.

\noindent \textbf{Notice}

This is an efficient operation of complexity $O(N)$ \textsl{(for contiguous overlaps)}
or $O(N \times \log M)$ \textsl{(for overlaps with gaps)}.


\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos\_B: u8} -- Stack position of $Vector B$ relative to \texttt{[TOS]}.
\item \texttt{lab\_A: u8} -- Stack position of $Labels A$ relative to \texttt{[TOS]}.
\item \texttt{lab\_B: u8} -- Stack position of $Labels B$ relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- Vector A
\item \texttt{[TOS - pos\_B: Vector]} -- Vector B
\item \texttt{[TOS - lab\_A: Labels]} -- Labels A
\item \texttt{[TOS - lab\_B: Labels]} -- Labels B
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]}: -- $Vector A$ updated by replacing values from $Vector B$ mapping them through projection of $Labels B$ onto $Labels A$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    JUPD    2   4   5

\end{verbatim}

Update vector on stack at \texttt{[TOS]} by replacing its selected components with components of a vector at \texttt{[TOS - 2]},
using labels at \texttt{[TOS - 4]} for vector at \texttt{[TOS]}, and
using labels at \texttt{[TOS - 5]} for vector at \texttt{[TOS - 2]},
where labels overlap.

\subsubsection{\texttt{JADD} --- Add by Joining on Labels\label{inst:jadd}}

Add two $Vectors$ joining on $Labels$. Expands vector at \texttt{[TOS - pos\_B]} using labels at \texttt{[TOS - lab\_B]} 
to match labels of vector at \texttt{TOS} located on stack at \texttt{[TOS - lab\_A]}.

\noindent \textbf{Notice}

This is an efficient operation of complexity $O(N)$ \textsl{(for contiguous overlaps)}
or $O(N \times \log M)$ \textsl{(for overlaps with gaps)}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{pos\_B: u8} -- Stack position of $Vector B$ relative to \texttt{[TOS]}.
\item \texttt{lab\_A: u8} -- Stack position of $Labels A$ relative to \texttt{[TOS]}.
\item \texttt{lab\_B: u8} -- Stack position of $Labels B$ relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector A$
\item \texttt{[TOS - pos\_B: Vector]} -- $Vector B$
\item \texttt{[TOS - lab\_A: Labels]} -- $Labels A$
\item \texttt{[TOS - lab\_B: Labels]} -- $Labels B$
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]}: -- $Vector A$ updated by adding values from $Vector B$ mapping them through projection of $Labels B$ onto $Labels A$.
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    JADD    2   4   5

\end{verbatim}

Add to vector on stack at \texttt{[TOS]} selected components of a vector at \texttt{[TOS - 2]},
using labels at \texttt{[TOS - 4]} for vector at \texttt{[TOS]}, and
using labels at \texttt{[TOS - 5]} for vector at \texttt{[TOS - 2]},
where labels overlap.

\subsubsection{\texttt{JFLT} --- Filter by Joining on Labels\label{inst:jflt}}

Filter vector on stack at \texttt{[TOS]} retaining only components corresponding to labels at \texttt{[TOS - lab\_B]}
using labels at \texttt{[TOS - lab\_A]} for vector at \texttt{[TOS]}, and
where labels overlap.

\noindent \textbf{Notice}

This is an efficient operation of complexity $O(N)$ \textsl{(for contiguous overlaps)}
or $O(N \times \log M)$ \textsl{(for overlaps with gaps)}.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{lab\_A: u8} -- Stack position of $Labels A$ relative to \texttt{[TOS]}.
\item \texttt{lab\_B: u8} -- Stack position of $Labels B$ relative to \texttt{[TOS]}.
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{[TOS: Vector]} -- $Vector A$
\item \texttt{[TOS - lab\_A: Labels]} -- $Labels A$
\item \texttt{[TOS - lab\_B: Labels]} -- $Labels B$
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{[TOS: Vector]}: -- $Vector A$ filtered by retaining components through projection of $Labels B$ onto $Labels A$.
\end{itemize}   

\noindent \textbf{Usage Example}

\begin{verbatim}

    JFLT    4   5

\end{verbatim}

Filter vector on stack at \texttt{[TOS]} retaining only components corresponding to labels at \texttt{[TOS - 5]}
using labels at \texttt{[TOS - 4]} for vector at \texttt{[TOS]}, and
where labels overlap.

\pagebreak
\subsection{5. Arithmetic \& Core Math (Opcode 50..55)}

\subsubsection{\texttt{ADD} --- \label{inst:add}}

Add TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos, TOS: Vector|Scalar]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    ADD <pos>

\end{verbatim}

\subsubsection{\texttt{SUB} --- \label{inst:sub}}

Subtract TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos, TOS: Vector|Scalar]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    SUB <pos>

\end{verbatim}

\subsubsection{\texttt{SSB} --- \label{inst:ssb}}

Saturating subtract TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos, TOS: Vector|Scalar]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    SSB <pos>

\end{verbatim}

\subsubsection{\texttt{MUL} --- \label{inst:mul}}

Multiply TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos, TOS: Vector|Scalar]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    MUL <pos>

\end{verbatim}

\subsubsection{\texttt{DIV} --- \label{inst:div}}

Divide TOS by operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos, TOS: Vector|Scalar]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    DIV <pos>

\end{verbatim}

\subsubsection{\texttt{SQRT} --- \label{inst:sqrt}}

Square root of TOS (scalar or component-wise vector). Works with vectors and scalars. In-place updates operand on TOS.

\noindent \textbf{Operands}

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS: Vector|Scalar]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    SQRT

\end{verbatim}

\pagebreak
\subsection{6. Logic \& Comparison (Opcode 60..61)}

\subsubsection{\texttt{MIN} --- \label{inst:min}}

Min between TOS and operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos, TOS: Vector|Scalar]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS: Vector|Scalar]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    MIN <pos>

\end{verbatim}

\subsubsection{\texttt{MAX} --- \label{inst:max}}

Max between TOS and operand at $[T-pos]$. Works with vectors and scalars. In-place updates operand on TOS. Does not consume the other operand.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos, TOS: Vector|Scalar]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS: Vector|Scalar]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    MAX <pos>

\end{verbatim}

\pagebreak
\subsection{7. Vector Aggregation (Opcode 70..72)}

\subsubsection{\texttt{VSUM} --- \label{inst:vsum}}

Sum of all vector components. Pushes on TOS. Does not consume the operand.

\noindent \textbf{Operands}

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS: Vector]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS: Scalar]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    VSUM

\end{verbatim}

\subsubsection{\texttt{VMIN} --- \label{inst:vmin}}

Minimum value found within vector components. Pushes on TOS. Does not consume the operand.

\noindent \textbf{Operands}

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS: Vector]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS: Scalar]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    VMIN

\end{verbatim}

\subsubsection{\texttt{VMAX} --- \label{inst:vmax}}

Maximum value found within vector components. Pushes on TOS. Does not consume the operand.

\noindent \textbf{Operands}

\begin{itemize}
\item (no operands)
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS: Vector]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS: Scalar]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    VMAX

\end{verbatim}

\pagebreak
\subsection{8. Immediate Values \& Vector Creation (Opcode 80..83)}

\subsubsection{\texttt{IMMS} --- \label{inst:imms}}

Push immediate Scalar value on stack

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<immediate}: \texttt{u128} Stack pos
\item \texttt{(scalar)>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{no stack args}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS: Scalar]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMMS <immediate (scalar)>

\end{verbatim}

\subsubsection{\texttt{IMML} --- \label{inst:imml}}

Push immediate Label value on stack

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<immediate}: \texttt{u128} Stack pos
\item \texttt{(label)>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{no stack args}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS: Label]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    IMML <immediate (label)>

\end{verbatim}

\subsubsection{\texttt{ZEROS} --- \label{inst:zeros}}

Create Vector of zeros matching length of Labels at $[T-pos]$. Pushes on TOS. Does not consume the operand.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos: Vector|Labels]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS: Vector]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    ZEROS <pos>

\end{verbatim}

\subsubsection{\texttt{ONES} --- \label{inst:ones}}

Create Vector of ones matching length of Labels at $[T-pos]$. Pushes on TOS. Does not consume the operand.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos: Vector|Labels]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS: Vector]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    ONES <pos>

\end{verbatim}

\pagebreak
\subsection{9. Stack Control \& Program Flow (Opcode 90..94)}

\subsubsection{\texttt{POPN} --- \label{inst:popn}}

Pop 'n' values from the stack

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<count>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $['B..., TOS - count, ..., TOS]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $['B...]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    POPN <count>

\end{verbatim}

\subsubsection{\texttt{SWAP} --- \label{inst:swap}}

Swap TOS with operand at $[T-n]$

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<pos>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - pos: 'A, TOS: 'B]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS - pos: 'B, TOS: 'A]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    SWAP <pos>

\end{verbatim}

\subsubsection{\texttt{B} --- \label{inst:b}}

Call sub-routine stored as Labels at `prg\_id`, supplying `N` inputs and taking `M` outputs from stack. `N` inputs are consumed from stack. `M` outputs are moved from sub-routine's TOS to caller's TOS.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<prg\_id>}: \texttt{u128} Stack pos
\item \texttt{<N>}: \texttt{u128} Stack pos
\item \texttt{<M>}: \texttt{u128} Stack pos
\item \texttt{<R>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{stack args = $[TOS - N]$}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{result = $[TOS - M]$}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    B <prg_id> <N> <M> <R>

\end{verbatim}

\subsubsection{\texttt{FOLD} --- \label{inst:fold}}

Fold (iterate) over vector/label operands. Same as `B` except sub-routine is called repeatedly over components of Vector at TOS.

\noindent \textbf{Operands}

\begin{itemize}
\item \texttt{<prg\_id>}: \texttt{u128} Stack pos
\item \texttt{<N>}: \texttt{u128} Stack pos
\item \texttt{<M>}: \texttt{u128} Stack pos
\item \texttt{<R>}: \texttt{u128} Stack pos
\end{itemize}

\noindent \textbf{Stack Args}

\begin{itemize}
\item \texttt{}: Input
\end{itemize}

\noindent \textbf{Return}

\begin{itemize}
\item \texttt{}: Output
\end{itemize}

\noindent \textbf{Usage Example}

\begin{verbatim}

    FOLD <prg_id> <N> <M> <R>

\end{verbatim}



\end{document}