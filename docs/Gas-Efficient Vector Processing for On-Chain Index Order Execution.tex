\documentclass[11pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
\usepackage{enumitem}

\title{\textbf{Gas-Efficient Vector Processing for On-Chain Index Order Execution}}
\author{Sonia Kolasinska, IndexMaker Labs}
\date{\today}

\begin{document}

\maketitle
\setlength{\parskip}{0.8em}


\begin{abstract}
The execution of financial primitives involving baskets of underlying assets poses a significant computational challenge in constrained smart contract environments. This paper formalizes a novel, high-dimensional algorithm, implemented on a $\text{VM}^2$ environment, which is a Virtual Machine deployed as a smart contract (Stylus/WASM). This $\text{VM}^2$ is optimized for vector processing using its \textbf{Vector Intermediate Language (VIL)}, designed to execute complex index order primitives (Buy, Sell, Rebalance) and dynamically update the index quote and margin parameters. The complete system operation integrates six key steps: (1) dynamically deriving the index quote (Price, Slope, Capacity), (2) updating the Vendor's net supply and market delta, (3) solving a vector-based quadratic pricing equation, (4) determining a systemic margin capacity limit, (5) performing complex market demand rebalancing, and (6) updating final net exposure (Delta). Furthermore, we detail the maintenance VIL routines essential for robust, continuous operation, including market data integration, margin limit updates, and asset list expansion. A crucial component of this low-cost execution is the selection of the VIL's Join-operation implementation, which is formally justified by comparative gas cost analysis, ensuring $\mathbf{O(N_I + N_M)}$ complexity and cost predictability. We demonstrate that this approach successfully manages a flexible Index structure (e.g., a 50-asset index) against a 150-asset Market, utilizing the VIL's labels manipulation to handle various index sizes (e.g., top 20, top 100). This capability is crucial to quantifying the operational cost and providing a blueprint for efficient, high-fidelity vector arithmetic on a blockchain.
\end{abstract}

\section{Introduction to the Problem}

Decentralized finance protocols increasingly rely on complex, multi-asset products. An index, composed of $N_I$ assets (e.g., $N_I \in \{20, 50, 100\}$), must interact with a broader market environment of $N_M$ assets (where $N_M=150$). The specific case where $N_I=50$ is used throughout this analysis as an illustrative example of an index being a portion of the total market. The core difficulty lies in processing high-dimensional vectors (up to $N_M$ components) entirely on-chain, where computation is constrained and expensive. Traditional Ethereum Virtual Machine (EVM) operations struggle with loop-based, element-wise vector arithmetic, leading to prohibitive gas costs for products requiring continuous rebalancing.

This challenge is overcome by deploying a separate, custom $\text{VM}^2$ environment, which is the \textbf{Vector IL VM} running inside the Arbitrum WASM VM (implemented as a smart contract compiled via Stylus). The $\text{VM}^2$'s core advantage lies in its specialized \textbf{Vector Instruction Set (VIS)}, providing native, low-level vector operations (e.g., $\mathbf{A} \oplus \mathbf{B}$). Critically, the VIS includes \textbf{Labels Manipulation} instructions (`JFLT', `JUPD', `JADD'). These commands are essential for correctly aligning and propagating data between the Index domain (e.g., 50 components) and the Market domain (150 components) without compromising state integrity.

It is critical to note that the internal execution complexity of these Label Manipulation instructions is linear, specifically $O(N_I + N_M)$ where $N_I$ is the index size and $N_M$ is the market size. However, this contained $O(N_I + N_M)$ complexity within the highly optimized VIL VM represents a transformative gas saving compared to an EVM implementation. The alternative's gas cost is dominated by the necessity of performing high-cost storage operations ($\text{SLOAD}$ \& $\text{SSTORE}$) on the underlying blockchain, which makes it prohibitively expensive. By performing this alignment in a single VIL operation, the overall transaction maintains a flat, low gas cost profile. The goal is to define an algorithm that is computationally efficient and mathematically sound, ensuring the transaction satisfies pricing, collateral, and systemic (Margin) constraints simultaneously.

\section{Decentralized Architecture and Thematic Roles (DeIndex)}

The system is formally known as the \textbf{Decentralised Index Maker (DeIndex)}. Its design is composed of several smart contract components and an off-chain coordinator, each assigned a thematic role to simplify the system's conceptual framework.

\begin{table}[h]
    \centering
    \renewcommand{\arraystretch}{1.2} % Increased row spacing
    \caption{Thematic Roles and Technical Functions of the DeIndex Architecture}
    \label{tab:architecture_roles}
    \begin{tabular}{l l p{7cm}}
        \toprule
        \textbf{Thematic Role} & \textbf{Technical Function} & \textbf{Summary} \\
        \midrule
        \textbf{Daxos (Hero)} & Main Contract & The main contract that orchestrates all transactions following the business logic. \\
        \textbf{DeVIL (Machine)} & Vector Math & An on-chain computation machine that can perform operations on vectors. It is $\text{VIL VM}$ in $\text{WASM VM}$  $(\text{VM}^2)$, which executes Vector Intermediate Language (VIL) code. \\       
        \textbf{Vault (Safe)} & Index Token $\text{(ITP)}$ & The tokenized derivative (the index primitive) being bought, sold, or rebalanced. \\
        \textbf{Vendor (Merchant)} & Authorized Provider & The off-chain service responsible for providing supply and pricing to the $\text{Market}$. \\
        \textbf{Market (Place)} & Supply \& Demand & Stores all critical system vectors: Supply, Demand, Delta, Price, Slope, and Margin. \\
        \bottomrule
    \end{tabular}
\end{table}

Throughout the paper, references to the \textbf{Vendor} refer to the entity responsible for coordinating asset transfers (as detailed in Section \ref{sec:vendor_role}) and committing new market data (Section \ref{sec:maintenance_routines}), while the \textbf{Market} refers to the immutable on-chain state vectors themselves.

\section{Quote Determination via Vector Processing}\label{sec:quote_determination}

Before any order execution can take place, the core pricing and capacity parameters of the index must be derived from the underlying market data. This process is handled by the VIL function \texttt{update\_quote} and is critical for ensuring the index price accurately reflects the sum of its components and that the system capacity respects underlying asset liquidity. The Index Quote comprises the Price ($P$), the Slope ($S$), and the Market Capacity ($C$).

\subsection{Index Price Determination (\textsl{P})}

The Index Price ($P$) is defined as the weighted sum of the current filtered market prices ($\mathbf{P}_i$) of the index's constituent assets. This calculation demonstrates the fundamental use of the VIL's $\text{JFLT}$ (Join-Filter) instruction to align the 150-component market prices with the 50-component index weights ($\mathbf{W}$) before performing the summation.

\[
P = \sum_{i} \mathbf{W}_i \cdot \mathbf{P}_i
\]

\subsection{Index Slope Determination (\textsl{S})}

The Index Slope ($S$) governs the convexity of the index's pricing function, ensuring that larger orders incur a higher marginal cost (similar to a bonding curve). This design ensures the aggregate index cost function follows the quadratic form:
\[
C = P \cdot Q + S \cdot Q^2
\]
where $C$ is the total cost for an Index quantity $Q$. The total cost must equal the sum of the individual assets' costs. The quadratic price impact term for a single asset $i$ is $\text{Cost}_{\text{impact}, i} = \mathbf{S}_i \cdot \mathbf{A}_i^2$, where $\mathbf{A}_i$ is the executed quantity of asset $i$. Since $\mathbf{A}_i = Q \cdot \mathbf{W}_i$ (the executed asset quantity is proportional to the Index quantity and the asset's weight), we substitute this into the total quadratic impact cost:
\[
\text{Cost}_{\text{impact}} = \sum_{i} \mathbf{S}_i \cdot \mathbf{A}_i^2 = \sum_{i} \mathbf{S}_i \cdot (Q \cdot \mathbf{W}_i)^2 = Q^2 \cdot \sum_{i} (\mathbf{S}_i \cdot \mathbf{W}_i^2)
\]
By comparing this derived term ($Q^2 \cdot \sum_{i} (\mathbf{S}_i \cdot \mathbf{W}_i^2)$) to the aggregate quadratic term ($S \cdot Q^2$), the Index Slope $S$ is formally defined as the weighted sum of the underlying assets' market slopes ($\mathbf{S}_i$), utilizing the square of the index weights ($\mathbf{W}_i^2$):
\[
S = \sum_{i} \mathbf{S}_i \cdot \mathbf{W}_i^2
\]

\subsection{Index Market Capacity Determination (\textsl{C})}\label{sec:index_capacity}

The Market Capacity ($C$) sets the absolute upper bound on the index quantity that can be traded, based on the liquidity constraints of the underlying assets. This is determined by the most restrictive asset, requiring a component-wise division followed by a vector-wide minimum extraction. This value is used as the $\text{Cap}$ input in the order execution logic (Section \ref{sec:margin_capacity_limit}).

\[
C = \min_{i} \left( \frac{\mathbf{L}_i}{\mathbf{W}_i} \right)
\]
where $\mathbf{L}_i$ is the market liquidity of asset $i$. The VIL efficiently computes this using $\text{DIV}$ (component-wise) and $\text{VMIN}$ (vector-wide minimum).

\section{The Vendor's Role and Market State Update}
\label{sec:vendor_role}

The Vendor, which indirectly invokes the VIL execution, is responsible for maintaining the system's overall health and managing the inventory of underlying assets. This involves two critical steps: updating the \textbf{Supply} vectors ($\mathbf{S}_L$, $\mathbf{S}_S$) based on external asset transfers, and calculating the resultant \textbf{Net Exposure (Delta)} vectors ($\Delta_L$, $\Delta_S$). This is handled by the \texttt{update\_supply} VIL function.

The Vendor's primary role (see Figure~\ref{fig:market_vendor}) is satisfying demand for assets by providing adequate supply. This effectively means maintaining the $\Delta_L$ and $\Delta_S$ vectors below a certain operational threshold, $\text{MinOrderSize}$. Specifically, the Vendor is considered dormant if $\max(\Delta_L, \Delta_S) < \text{MinOrderSize}$. Conversely, if $\Delta_L > \text{MinOrderSize}$, the Vendor starts selling assets to reduce the long exposure ($\Delta_L$). If $\Delta_S > \text{MinOrderSize}$, the Vendor starts buying new assets to cover the short exposure ($\Delta_S$). The Vendor's \textbf{active objective} is to always maintain $\max(\Delta_L, \Delta_S) < \text{MinOrderSize}$ through these proactive buy/sell operations.

\begin{figure}[h!]
    \centering\label{fig:market_vendor}
    \includegraphics[width=0.8\textwidth]{market_vendor.png}
    \caption{User vs. Vendor}
\end{figure}

\subsection{Supply Update via External Transfers}

The Vendor manages the available supply of each underlying asset. These supplies are represented by $\mathbf{S}_L$ (Long Supply, assets available for shorting) and $\mathbf{S}_S$ (Short Supply, assets available for selling long). The supply vectors are updated with external transfers ($\mathbf{A}_{L}$, $\mathbf{A}_{S}$) from the broader market using the VIL's $\text{JUPD}$ (Join-Update) instruction. This is a vector-aware replacement for simple storage updates.

\[
\mathbf{S}_{L, new} = \mathbf{S}_L \text{ join\_update } \mathbf{A}_{L}
\]

\[
\mathbf{S}_{S, new} = \mathbf{S}_S \text{ join\_update } \mathbf{A}_{S}
\]

where $\mathbf{A}_{L}$ and $\mathbf{A}_{S}$ are the vectors of asset quantities received by the Vendor, and $\text{join\_update}$ performs the update only on assets present in the index's domain, effectively applying the VIL $\text{JUPD}$ instruction for correct vector alignment.

\subsection{Net Exposure (Delta) Calculation}

The net exposure, or Delta, represents the system's current net position on each asset after accounting for all market activities (Supply and Demand). It is calculated by normalizing the total available assets ($\mathbf{T}_L, \mathbf{T}_S$) using the VIL's $\text{SSB}$ (Saturating Subtraction) instruction, which ensures that an asset's net position is either entirely long or entirely short (i.e., $\Delta_L$ and $\Delta_S$ are mutually exclusive, element-wise).

The total Long and Short asset vectors ($\mathbf{T}_L, \mathbf{T}_S$) are first computed:

\[
\mathbf{T}_L = \mathbf{S}_{L, new} \oplus \mathbf{D}_S
\]

\[
\mathbf{T}_S = \mathbf{S}_{S, new} \oplus \mathbf{D}_L
\]

where $\mathbf{D}_S$ and $\mathbf{D}_L$ are the current market Short and Long Demand vectors, respectively.

The final net exposure vectors are derived by:

\[
\Delta_{L, new} = \mathbf{T}_L \ominus \mathbf{T}_S \quad \text{(using SSB in VIL)}
\]

\[
\Delta_{S, new} = \mathbf{T}_S \ominus \mathbf{T}_L \quad \text{(using SSB in VIL)}
\]

The $\text{SSB}$ operation is critical here, as it ensures that for any asset $i$, if $T_{L, i} > T_{S, i}$, then $\Delta_{S, i} = 0$, and vice versa, maintaining the integrity of the margin system.

\section{Market Data Integrity and Maintenance Routines}\label{sec:maintenance_routines}

For the system to maintain a continuous, accurate, and solvent state, several maintenance routines must be executed periodically. These operations are also implemented as specialized VIL routines to ensure vector integrity and computational efficiency. They primarily rely on the VIL's `JUPD` (Join-Update) instruction to merge new data vectors with existing market vectors ($\mathbf{V}_{\text{old}}$) based on the asset label space, which is critical for the $N_M=150$ assets.

\subsection{Data Feed Integration (\texttt{update\_market\_data})}

The \texttt{update\_market\_data} routine is executed by the \textbf{Vendor (Authorized Provider)}. The Vendor is responsible for the computation of the core market vectors ($\mathbf{P}, \mathbf{S}, \mathbf{L}$) from raw, off-chain order book data before injection. This process ensures that the on-chain state accurately reflects real-time liquidity and price impact, thereby maintaining system solvency.

For each asset, the Vendor processes the top $K$ levels (e.g., $K=5$) of the order book (Bids and Asks) to derive the three key vector components ($\mathbf{P}_i, \mathbf{S}_i, \mathbf{L}_i$):

\begin{enumerate}
    \item \textbf{Liquidity ($\mathbf{L}$):} The available liquidity, $\mathbf{L}_i$, is defined as the total sum of quote-side depth within the scanned $K$ levels on both the bid and ask sides. Let $Q_{B k}$ be the quantity at bid level $k$ and $Q_{A k}$ be the quantity at ask level $k$.
    \[
    \mathbf{L}_i = \sum_{k=1}^{K} Q_{B k} + \sum_{k=1}^{K} Q_{A k}
    \]

    \item \textbf{Price ($\mathbf{P}$):} The asset's spot price, $\mathbf{P}_i$, is defined as the \textbf{Micro-Price} (Mid-Price weighted by the best-level liquidity), which reduces volatility and bias toward the side with less depth. Let $P_{B 1}$ and $P_{A 1}$ be the best bid and ask prices, and $Q_{B 1}$ and $Q_{A 1}$ be the corresponding best quantities.
    \[
    \mathbf{P}_i = \frac{P_{A 1} \cdot Q_{B 1} + P_{B 1} \cdot Q_{A 1}}{Q_{B 1} + Q_{A 1}}
    \]

    \item \textbf{Slope ($\mathbf{S}$):} The market slope, $\mathbf{S}_i$, quantifies the price impact across the $2K$ levels. It is calculated as the total price range spanned by the $K^{th}$ levels divided by the total liquidity $\mathbf{L}_i$ within that range. Let $P_{A K}$ be the price of the $K^{th}$ ask level and $P_{B K}$ be the price of the $K^{th}$ bid level.
    \[
    \mathbf{S}_i = \frac{P_{A K} - P_{B K}}{\mathbf{L}_i}
    \]
\end{enumerate}

These calculated vectors are then injected into the Market state using the VIL's $\text{JUPD}$ instruction to update only the specified assets:
\begin{itemize}
    \item \textbf{Prices ($\mathbf{P}$)}: The current price of each asset.
    \item \textbf{Slopes ($\mathbf{S}$)}: The current market slope/depth for each asset.
    \item \textbf{Liquidity ($\mathbf{L}$)}: The available liquidity for each asset used to calculate capacity.
\end{itemize}
The routine uses the $\text{JUPD}$ instruction to apply the new values only for the assets explicitly included in the input vector, leaving all other assets in the 150-component vector unchanged.

\[
\mathbf{P}_{\text{new}} = \mathbf{P}_{\text{old}} \text{ join\_update } \mathbf{P}_{\text{input}}
\]

Similarly for $\mathbf{S}_{\text{new}}$ and $\mathbf{L}_{\text{new}}$.

\subsection{Margin Headroom Update (\texttt{update\_margin})}

The maximum allowed net exposure vector ($\mathbf{M}$), which defines the systemic limit (Margin Headroom), must also be dynamically adjustable. The \texttt{update\_margin} routine allows the Vendor or governance mechanism to inject new margin limits, also using the $\text{JUPD}$ instruction for selective updates.

\[
\mathbf{M}_{\text{new}} = \mathbf{M}_{\text{old}} \text{ join\_update } \mathbf{M}_{\text{input}}
\]

\subsection{Market Asset Expansion (\texttt{update\_assets})}

One of the most powerful VIL operations is the atomic expansion of the Market Asset Names ($N_M$) list. The \texttt{update\_assets} routine handles the addition of new tokens to the market's domain (e.g., increasing $N_M$ from 150 to 155). This is achieved by extending the master list of asset names and subsequently extending all associated vectors ($\mathbf{P}, \mathbf{S}, \mathbf{L}, \mathbf{S}_L, \mathbf{S}_S, \mathbf{D}_L, \mathbf{D}_S, \Delta_L, \Delta_S, \mathbf{M}$) to the new dimension. For any newly added asset, its corresponding vector components are initialized to zero using a $\text{ZEROS}$ vector and the $\text{JUPD}$ instruction, thus maintaining a safe initial state with no exposure, liquidity, or demand.

\section{Mathematical Framework for Index Acquisition}

The execution algorithm is an atomic, six-step process. Variables denoted in bold ($\mathbf{V}$) are vectors, while italic variables ($s$) are scalars. Operations $\oplus, \ominus, \odot, \oslash$ represent vector addition, saturating subtraction, component-wise multiplication, and component-wise division, respectively. $\min(\mathbf{V})$ denotes the minimum value across all vector components. \textbf{Note: When a scalar ($s$) is used in a vector operation (e.g., $\min(\mathbf{V}, s)$ or $s \odot \mathbf{W}$), it implies a component-wise operation where the scalar is broadcast to a vector of matching dimension.}

\subsection{Step 1: Collateral Update and Single-Step Limit (\textsl{MaxOrderSize})}

The user's effective collateral ($C_{\text{eff}}$) is calculated based on initial funds ($C_{\text{old}}$) and external transfers ($C_{add}, C_{rem}$). The final usable collateral is immediately capped by the system-defined maximum order size ($\text{MaxOrderSize}$).

\textbf{Role of $\text{MaxOrderSize}$:} This scalar limit serves as an execution fragmentation tool. It dictates the maximum dollar value of an index quantity that can be executed in a single atomic VIL call. For large orders, this fragmentation into smaller steps ensures that the order progresses optimally along the quadratic price curve, benefiting both small orders (by preventing a single large order from dominating the price impact) and the overall execution quality of large orders (by achieving a better average price across steps).

The total current collateral pool ($C_{\text{new}}$) is:

\[
C_{\text{new}} = (C_{\text{old}} + C_{add}) - C_{rem}
\]

The effective collateral used for the pricing calculation ($C_{\text{eff}}$) is:

\[
C_{\text{eff}} = \min(\text{MaxOrderSize}, C_{\text{new}})
\]

The market provides the scalar Index Price Slope ($S$) and Price ($P$), which define the marginal cost function for the total index quantity $Q$. These are the values computed in Section \ref{sec:quote_determination}.

\subsection{Step 2: Maximum Quantity Determination via Quadratic Solver}

The maximum possible Index Quantity based on collateral ($Q_{\text{max, pricing}}$) is determined by solving the Index Price Function, which links the effective cost ($C_{\text{eff}}$) to the quantity ($Q$): $C_{\text{eff}} = P \cdot Q + S \cdot Q^2$.

This is reformulated into a standard scalar quadratic equation:

\[
S \cdot Q^2 + P \cdot Q - C_{\text{eff}} = 0
\]

The maximum quantity is found by taking the positive root of the solution:

\[
Q_{\text{max, pricing}} = \frac{\sqrt{P^2 + 4 \cdot S \cdot C_{\text{eff}}} - P}{2 \cdot S}
\]

\subsection{Step 3: Margin-Based Capacity Limit (\textsl{CL}) with Progressive Constraint}
\label{sec:margin_capacity_limit}

To prevent systemic limits breaches, the transaction must be capped by the market's remaining margin capacity ($\mathbf{M}$) relative to the current long ($\Delta_L$) and short ($\Delta_S$) exposures. The \textbf{Final Capacity Limit ($CL$)} for the entire index purchase is defined by the minimum available capacity across all assets, \textbf{constrained progressively by the $\mathbf{AssetContributionFractions}$ vector ($\mathbf{F}$)}.

\textbf{Role of $\mathbf{F}$:} This vector $\mathbf{F}$ is derived from a batch of pending index orders. It ensures that the available margin capacity of bottleneck assets is split proportionally among the batch of orders, guaranteeing that the orders can progress and preventing any single large order from blocking the entire batch.

\[
CL = \min \left( \mathbf{F} \odot \frac{\mathbf{L}}{\mathbf{W}} \right)
\]

\begin{enumerate}
    \item \textbf{Margin Limit Vector ($\mathbf{L}$):} The available capacity ($\mathbf{L}$) is the \textbf{sum} of the system's available resources: the \textbf{Inventory} that can be closed ($\Delta_L$ or $\Delta_S$) plus the \textbf{Remaining Margin Headroom}, capped by the equivalent vector for the scalar Market Capacity ($C \odot \mathbf{W}$).

    \begin{itemize}
        \item \textbf{For a Buy Order} (either reducing $\Delta_L$ or increasing $\Delta_S$):
        \[
        \mathbf{L} = \Delta_L \oplus \min(\mathbf{M} \ominus \Delta_S, C \odot \mathbf{W})
        \]

        \item \textbf{For a Sell Order} (either reducing $\Delta_S$ or increasing $\Delta_L$):
        \[
        \mathbf{L} = \Delta_S \oplus \min(\mathbf{M} \ominus \Delta_L, C \odot \mathbf{W})
        \]
    \end{itemize}
    
    \textbf{Note:} $\mathbf{M}$ represents the maximum allowed net exposure, which serves as a \textbf{hard, systemic upper limit} such that $\text{Abs}(\Delta_L \oplus \Delta_S) \le \mathbf{M}$ must always be true. This Margin ($\mathbf{M}$) is typically equivalent to the total Vendor-managed reserves. The Market Capacity $C$ used here is derived from the \texttt{update\_quote} function (Section \ref{sec:index_capacity}). Since $\Delta_L$ and $\Delta_S$ are mutually exclusive (an asset cannot be net long and net short simultaneously), the additive vector operation ($\oplus$) correctly aggregates the two distinct sources of capacity.

    \item \textbf{Asset Capacity Limit Vector ($\mathbf{CL}_{\text{vec}}$):} This vector is aligned via Label Manipulation (`JFLT`) to the Index Asset Weights ($\mathbf{W}$) and determines the maximum \textit{Index} quantity each asset can sustain.
    \item \textbf{Final Capacity Limit ($CL$):} The system capacity is the minimum across all assets after the asset-level capacity ($\mathbf{L} \oslash \mathbf{W}$) is constrained by the `AssetContributionFractions` vector ($\mathbf{F}$). This ensures that the current iterative order consumes no more than its allocated fraction of the total remaining margin.

    \[
    CL = \min \left( \mathbf{F} \odot \left( \mathbf{L} \oslash \mathbf{W} \right) \right)
    \]

\end{enumerate}

\subsection{Step 4: Final Quantity Execution and Asset Calculation}

The executed Index Quantity ($Q_{\text{final}}$) is capped by the maximum allowed by pricing ($Q_{\text{max, pricing}}$) and the Margin Capacity ($CL$).

\[
Q_{\text{final}} = \min(Q_{\text{max, pricing}}, CL)
\]

The resulting executed asset quantities ($\mathbf{A}$) are calculated by distributing $Q_{\text{final}}$ according to the Index Weights ($\mathbf{W}$).

\[
\mathbf{A} = Q_{\text{final}} \odot \mathbf{W}
\]

\subsection{Step 5: Market Demand Rebalancing}

This is next step, where the 50-component $\mathbf{A}$ vector updates the 150-component market demand vectors ($\mathbf{D}_S, \mathbf{D}_L$).

\begin{enumerate}
    \item \textbf{New Short Demand ($\mathbf{D}_{S, new}$):} The executed assets reduce the standing short demand, saturating at zero.

    \[
    \mathbf{D}_{S, new} = \mathbf{D}_S \ominus \mathbf{A}
    \]

    \item \textbf{Residual Quantities ($\mathbf{R}_{\text{A}}$):} Any asset quantities that could not be matched by existing short demand become residual.

    \[
    \mathbf{R}_{\text{A}} = \mathbf{A} \ominus \mathbf{D}_S
    \]

    \item \textbf{New Long Demand ($\mathbf{D}_{L, new}$):} The residual quantities are added to the long demand.

    \[
    \mathbf{D}_{L, new} = \mathbf{D}_L \oplus \mathbf{R}_{\text{A}}
    \]
\end{enumerate}

\subsection{Step 6: Delta Update and Financial Commit}

The final net exposures ($\Delta_L, \Delta_S$) are updated based on the new demand/supply state ($\mathbf{D}_S$, $\mathbf{D}_L$, $\mathbf{S}_L$, $\mathbf{S}_S$).

\[
\mathbf{T}_L = \mathbf{S}_L \oplus \mathbf{D}_{S, new} \quad ; \quad \mathbf{T}_S = \mathbf{S}_S \oplus \mathbf{D}_{L, new}
\]

\[
\Delta_{L, new} = \mathbf{T}_L \ominus \mathbf{T}_S \quad ; \quad \Delta_{S, new} = \mathbf{T}_S \ominus \mathbf{T}_L
\]

The order's spent collateral is calculated: $C_{\text{spent}} = Q_{\text{final}} \cdot (S \cdot Q_{\text{final}} + P)$. All market and order state vectors are then committed.

\section{Performance Analysis and Efficiency}

The efficiency of this vectorized execution, even with the complex $50 \rightarrow 150$ vector alignment, is quantified by the observed gas cost.

\subsection{Observed Transaction Cost}

The analyzed transaction required \textbf{3,461,868 gas} to execute, based on the provided transaction receipt. This cost is incurred for the following operations:
\begin{itemize}
    \item Solving the scalar quadratic equation.
    \item Performing exactly 11 vector arithmetic operations ($\oplus, \ominus, \odot, \oslash$) on vectors up to 150 components.
    \item Executing exactly 4 Label Manipulation instructions (`JFLT`, `JUPD`, `JADD`) to align and commit data between the Index and Market domains.
\end{itemize}

\begin{table}[h]
    \centering
    \caption{Transaction Cost and Scale Summary (Gas Price: 100 Gwei)}\label{tab:cost_summary}
    \begin{tabular}{p{3cm} p{6cm} p{5.5cm}}
        \toprule
        \textbf{Metric} & \textbf{Value} & \textbf{Cost Equivalency (at 100 Gwei)} \\
        \midrule
        \textbf{Total Gas Used} & $\mathbf{3,461,868}$ & Actual on-chain consumption \\
        \textbf{Asset Scale} & $N_I=50 \text{ vs. } N_M=150$ & High dimensional processing \\
        \textbf{ETH Cost} & $3,461,868 \cdot 100 \cdot 10^{-9} \text{ ETH}$ & $\mathbf{0.0003461868} \text{ ETH}$ \\
        \textbf{USD Cost} & $0.0003461868 \text{ ETH} \times \$3,600/\text{ETH}^*$ & $\approx \mathbf{\$1.25} \text{ USD} \text{ (or } \mathbf{124.63} \text{ cents)}$ \\
        \bottomrule
        \multicolumn{3}{l}{\small $^*$Assuming an ETH price of $\$3,600$ for illustrative purposes.}
    \end{tabular}
\end{table}

\subsection{VIL Performance Analysis: Justification for Low Gas Cost}

The core of the low-cost execution is the efficient implementation of the VIL's \textbf{Join operations}: `JFLT` (Join-Filter), `JUPD` (Join-Update), and `JADD` (Join-Add). These operations are essential for aligning the asset index vector with the asset market vector. The paper, "Aligning Market and Index Vectors" (2025), provided a comparative analysis of four implementation strategies, summarized in Table \ref{tab:vil_performance}, which empirically justifies the mandated choice.

\subsubsection*{Comparative Analysis of VIL Implementations}

The challenge involves synchronizing two sorted vectors: a large Market Vector (150 components) and a smaller, sparse Input Vector (e.g., 50 components, potentially non-contiguous).

\begin{table}[htbp]
    \centering
    \small % Reduce font size for table
    \caption{Comparative Empirical Gas Costs (Test Sets A and B)}\label{tab:vil_performance}
    % Using p{width} columns for headers that need wrapping
    \setlength{\arraycolsep}{6pt} % Adjust horizontal space
    \renewcommand{\arraystretch}{1.2} % Set vertical spacing to 1.2 for this table as well
    \begin{tabular}{@{}l l r r@{}}
        \toprule
        \textbf{Version} & \textbf{Implementation Method} & \textbf{Gas Cost (Test A)} & \textbf{(Test B - Mixed Data)} \\
        \midrule
        \textbf{(a)} & Linear scan, filtering \textbf{in-place} & $3,380,000$ & $\mathbf{3,993,165}$ \\
        \textbf{(b)} & Linear scan, filtering and \textbf{appending} & $\mathbf{3,380,000}$ & $3,990,747$ \\
        \textbf{(c)} & Pure Binary Search and Append & $3,970,000$ & $3,991,967$ \\
        \textbf{(d)} & \textbf{Hybrid Linear/Logarithmic} & $3,420,000$ & $\mathbf{3,990,453}$ \\
        \bottomrule
    \end{tabular}
\end{table}

\subsubsection*{Justification for the Hybrid Solution (d)}

The analysis proved that deterministic, predictable performance is non-negotiable for a financial primitive operating on-chain:

\begin{enumerate}
    \item \textbf{Deterministic Safety:} Candidates (b), (c), and (d) are safe.
    \item \textbf{Stability Validation:} Solution (a) incurred the highest gas cost ($3,993,165$) under mixed-data conditions, proving its cost is volatile and unacceptable.
    \item \textbf{Comparative Efficiency:} The three deterministic solutions performed closely: Solution (d) at $3,990,453$ gas, Solution (b) at $3,990,747$ gas, and Solution (c) at $3,991,967$ gas. This confirms that the hybrid approach (\textbf{d}) is the most gas-efficient under these mixed-data conditions, validating the strategic decision to prioritize its adaptive logic.
\end{enumerate}

The implementation of the VIL's core instructions with the \textbf{Hybrid Solution (d)} appeared most optimal, enabling the complex, 6-step Index Buy Execution algorithm to maintain an extremely low, predictable overall transaction cost of $\approx \mathbf{\$1.25}$. This choice fundamentally guarantees that vector alignment overhead will not compromise the system's economic viability.

\section{Conclusion}

The Vectorized Index Buy Order Execution Algorithm provides a mathematically sound and highly performant mechanism for executing high-dimensional financial derivatives on-chain. The formalism highlights the balancing act between quote determination (Section \ref{sec:quote_determination}), Vendor state management (Section \ref{sec:vendor_role}), data integrity (Section \ref{sec:maintenance_routines}), pricing constraints ($Q_{\text{max, pricing}}$), systemic stability ($CL$), and market dynamics ($\mathbf{D}_{S, new}, \mathbf{D}_{L, new}$). By offloading vector operations and data alignment to the optimized VIS layer, underpinned by the empirically validated \textbf{Hybrid Solution (d)} for Label Manipulation, the system achieves a transaction cost of $\approx \mathbf{\$1.25}$ for a complex 50/150 asset trade, confirming the viability of vector-based financial primitives in decentralized ecosystems.

\end{document}